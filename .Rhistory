library(data.table)
library(stringdist)
source("www/utils.R")
ui <- fluidPage(
titlePanel("Kobo Checker App"),
tags$head(
tags$style(HTML(
"
#table-container {
overflow: visible !important;
}
"
)),
HTML(
'<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"/>'
),
includeCSS("www/style.css"),
HTML(
'<a style="padding-left:10px;" class="app-title" href= "https://www.reach-initiative.org/" target="_blank"><img src="reach.jpg" height = "50"></a><span class="app-description" style="font-size: 16px; color: #FFFFFF"><strong>Database_test</strong></span>'
),
),
hr(),
tabsetPanel(
tabPanel("Data Checker",
sidebarLayout(
sidebarPanel(
fileInput("file", "Choose your kobo tool", accept = ".xlsx"),
actionButton("processBtn", "Process Data")
),
mainPanel(
DTOutput("resultTable")
)
)
),
tabPanel("Question Inspection",
titlePanel("Survey Question Inspection"),
sidebarLayout(
sidebarPanel(
uiOutput("name_selector"),
actionButton("submit_btn", "Submit")
),
mainPanel(
tabsetPanel(
tabPanel("Tree View", echarts4rOutput("tree_chart")),
tabPanel("Relationship Matrix", tableOutput("matrix_table"))
)
)
)
)
)
)
# Server
server <- function(input, output, session) {
# Reactive values for storing data
data.tool <- reactiveVal(NULL)
data.choices <- reactiveVal(NULL)
label <- reactiveVal(NULL)
# Load data from file
observeEvent(input$file, {
res <- readxl::read_xlsx(input$file$datapath, sheet = "survey",
col_types = "text") %>% names()
label(res[grepl('english',tolower(res))][1])
labels <-label()
data.tool(load.tool.survey(input$file$datapath,labels,keep_cols = T))
data.choices(load.tool.choices(filename_tool = input$file$datapath,
label_colname = labels))
})
# Process data and update table
observeEvent(input$processBtn, {
if (!is.null(data.tool())) {
kobo_data.t <- data.tool()
kobo_data.c <- data.choices()
labels <- label()
kobo_data.t <- kobo_data.t %>%
filter(!grepl('\\bsettlement|\\brectangle\\b|\\brectangles\\b|geo_location|\\bpoint\\b|\\bhub\\b|raion|hromada|oblast|center_idp',list_name))
kobo_data.c <- kobo_data.c %>%
filter(!grepl('\\bsettlement|\\brectangle\\b|\\brectangles\\b|geo_location|\\bpoint\\b|\\bhub\\b|raion|hromada|oblast|center_idp',list_name),
!grepl("^UKRs\\d+$", name),
!grepl("^UA\\d+$", name))
# test for non eng in tool survey
non_eng.t <- kobo_data.t %>%
select(name, relevant,type) %>%
rownames_to_column(var='rownames') %>%
pivot_longer(cols= name:type, names_to = 'column', values_to = 'value') %>%
filter(!is.na(value),
!value==' ',
!grepl('\xc2\xa0+',value),
grepl("[^ -~]",value, perl=T)) %>%
mutate(cyrillic_char = regmatches(value,
gregexpr("[^ -~]",
value, perl = TRUE)) %>%unlist  %>%  paste(collapse = ''))
if(nrow(non_eng.t)>0){non_eng.t <- non_eng.t %>% mutate(issue = 'cyrillic',
file = 'tool.survey')}
# test for non eng in tool survey
non_eng.c <- kobo_data.c %>%
select(list_name,!!sym(labels),name) %>%
rownames_to_column(var='rownames') %>%
pivot_longer(cols= list_name:name, names_to = 'column', values_to = 'value') %>%
filter(!is.na(value),
!value==' ',
!grepl('\xc2\xa0+',value),
grepl("[^ -~]",value, perl=T)) %>%
rowwise() %>%
mutate(cyrillic_char = regmatches(value,
gregexpr("[^ -~]",
value, perl = TRUE)) %>%unlist  %>%  paste(collapse = '')) %>%
filter(!grepl('\\`|\\’|\\–|\\´',cyrillic_char ))
if(nrow(non_eng.c)>0){non_eng.c <- non_eng.c %>% mutate(issue = 'cyrillic',
file = 'tool.choices')}
non_eng <- bind_rows(non_eng.c,non_eng.t)%>%
mutate(priority = 'Second priority')
# test for leading/trailing spaces in tool survey
add.space.t <- kobo_data.t %>%
select(name) %>%
rownames_to_column(var='rownames') %>%
rename(value=name) %>%
filter(!is.na(value),
!value==' ',
grepl("^\\s+|\\s+$|\\s{2,}",value, perl=T))
if(nrow(add.space.t)>0){add.space.t <- add.space.t %>% mutate(issue = 'double/leading/trailing space',
file = 'tool.survey')}
# test for leading/trailing spaces in tool survey
add.space.c <- kobo_data.c %>%
filter(!grepl('geo',list_name)) %>%
select(name,!!sym(labels)) %>%
rownames_to_column(var='rownames') %>%
pivot_longer(cols= name:!!sym(labels), names_to = 'column', values_to = 'value') %>%
filter(!is.na(value),
!value==' ',
grepl("^\\s+|\\s+$|\\s{2,}",value, perl=T))
if(nrow(add.space.c)>0){add.space.c <- add.space.c %>%
mutate(issue = 'double/leading/trailing space',
file = 'tool.choices')
}else{add.space.c <- data.frame()}
add.space <- bind_rows(add.space.c,add.space.t)%>%
mutate(priority = 'Second priority')
# check for _other variables
other_check <- kobo_data.t %>%
filter(type=='text') %>%
filter(!is.na(relevant)) %>%
select(name,relevant) %>%
rownames_to_column(var='rownames') %>%
mutate(single_rel = relevant) %>%
tidyr::separate_rows(single_rel,sep='\\bor|\\band') %>%
mutate(single_rel=str_squish(single_rel)) %>%
filter(!grepl('not\\(selected',single_rel)) %>%
mutate(n_relevancies=str_count(relevant,'\\{'),
questions_values = sapply(single_rel, parse.formula),
question_names = sapply(single_rel, function(x){parse.formula(x,return='name')})) %>%
filter(grepl('other',questions_values))
# check number of others per question
other_check_n_others <- other_check %>%
group_by(question_names) %>%
mutate(count_others = sum(n())) %>%
filter(count_others>1) %>%
ungroup()
if(nrow(other_check_n_others)>0){
other_check_n_others <- other_check_n_others %>%
select(rownames,name,relevant)%>%
rename(value = relevant,
column = name) %>%
mutate(issue = 'Two others per 1 question. Pls fix',
file = 'tool.survey')%>%
mutate(priority = 'First priority')
}else(other_check_n_others <- data.frame())
other_n_rel <- other_check %>% filter(n_relevancies>1) %>%
select(rownames,name,relevant) %>%
rename(value = relevant,
column = name) %>%
mutate(issue = 'Double relevancy',
file = 'tool.survey')%>%
mutate(priority = 'First priority')
other_wrong_choice <- other_check %>% filter(!questions_values=='other') %>%
select(rownames,name,relevant) %>%
rename(value = relevant,
column = name) %>%
mutate(issue = 'Other choice is not called "other"',
file = 'tool.survey')%>%
mutate(priority = 'First priority')
other_wrong_name <- other_check %>% filter(!grepl('_other$',name)) %>%
select(rownames,name,relevant) %>%
rename(value = relevant,
column = name) %>%
mutate(issue = "The name of this 'other' value doesn't end with '_other' this will break the cleaning script",
file = 'tool.survey')%>%
mutate(priority = 'First priority')
other_checks <- bind_rows(other_n_rel,other_wrong_choice,other_wrong_name,other_check_n_others)
# check if all relevances match the available choices
check_rel <- kobo_data.t %>%
rownames_to_column(var='rownames') %>%
select(rownames,name, type, relevant) %>%
filter(!is.na(relevant),
grepl('select_multiple|select_one',type)) %>%
mutate(single_rel = relevant) %>%
tidyr::separate_rows(single_rel,sep='\\bor|\\band') %>%
filter(grepl('selected',single_rel))
if(nrow(check_rel)>0){
check_rel <- check_rel %>%
mutate(questions_values = sapply(single_rel, parse.formula),
question_names = sapply(single_rel, function(x){parse.formula(x,return='name')})) %>%
left_join(kobo_data.t %>% select(name,list_name) %>% rename(question_names=name)) %>%
rowwise() %>%
mutate(check =
questions_values %in% kobo_data.c[kobo_data.c$list_name==list_name,]$name
) %>%
filter(check==F & !questions_values=='') %>%
mutate(issue = paste0('Relevance value ',questions_values, ' is not present in the list ',list_name),
column = 'relevant',
file = 'tool.survey') %>%
rename(value=relevant) %>%
select(rownames,column,value,issue,file)%>%
mutate(priority = 'First priority')
}else{check_rel <- data.frame()}
# check constraints for having existing values
check_con <- kobo_data.t %>%
rownames_to_column(var='rownames') %>%
select(rownames,name, type, constraint) %>%
filter(!is.na(constraint),
grepl('select_multiple|select_one',type)) %>%
mutate(single_const = constraint) %>%
tidyr::separate_rows(single_const,sep='\\bor|\\band') %>%
filter(grepl('selected\\(\\$',single_const))
if(nrow(check_con)>0){
check_con <- check_con %>%
mutate(questions_values = sapply(single_const, parse.formula),
question_names = sapply(single_const, function(x){parse.formula(x,return='name')})) %>%
left_join(kobo_data.t %>% select(name,list_name) %>% rename(question_names=name)) %>%
rowwise() %>%
mutate(check =
questions_values %in% kobo_data.c[kobo_data.c$list_name==list_name,]$name
) %>%
filter(check==F & !questions_values=='') %>%
mutate(issue = paste0('Constraint value ',questions_values, ' is not present in the list ',list_name),
column = 'relevant',
file = 'tool.survey') %>%
rename(value=constraint) %>%
select(rownames,column,value,issue,file)%>%
mutate(priority = 'First priority')
}else{check_con <- data.frame()}
# Duplicate choices in list_choices
dupl_choices <- kobo_data.c %>%
rownames_to_column(var='rownames') %>%
group_by(list_name,name) %>%
mutate(dupobs = n()) %>%
filter(dupobs>1) %>%
ungroup()
if(nrow(dupl_choices)>0){
dupl_choices <- dupl_choices %>%
group_by(list_name) %>%
summarise(issue = paste0('duplicate name in list_name ',unique(list_name)),
rownames = min(rownames),
value = unique(name)) %>%
ungroup() %>%
select(-list_name) %>%
mutate(column = 'name',
file = 'tool.choices')%>%
mutate(priority = 'First priority')
}else{dupl_choices <- data.frame()}
# Check if None is in constraint if it's present in the list of choices
non_check <- kobo_data.t %>%
rownames_to_column(var='rownames') %>%
select(rownames,list_name,constraint) %>%
rowwise() %>%
mutate(check = any(grepl('none', kobo_data.c[kobo_data.c$list_name %in% list_name,]$name))) %>%
ungroup() %>%
mutate(check2 = grepl('none',constraint)) %>%
filter(check==T & check2==F)
if(nrow(non_check)>0){
non_check <- non_check %>%
select(rownames,constraint) %>%
rename(value=constraint) %>%
mutate(column = 'constraint',
issue = 'None is present in the list_name for the variable, but not in the constraint',
file = 'tool.survey')%>%
mutate(priority = 'Second priority')
}else{non_check <- data.frame()}
# Check if the names match the labels (at least somewhat)
label_issues <- kobo_data.c %>%
tibble() %>%
rownames_to_column(var='rownames') %>%
select(list_name,rownames,name,!!sym(labels)) %>%
mutate(name = tolower(gsub('_',' ',name)),
label = tolower(gsub('_',' ',!!sym(labels))),
label = gsub("\\(.*?\\)", "", label),
label = gsub("[[:punct:]]", "", label),
similarity = stringsim(
name,label,
method='jaccard',
q=2
)) %>%
rowwise() %>%
filter(similarity<0.2 & ! grepl(name,label) & !name=='idk') %>% ungroup()
if(nrow(label_issues)>0){
label_issues <- label_issues %>%
mutate(issue = paste0('The name "',name,'" is dissimlar to the label "',!!sym(labels),'". Please double check'),
column = labels,
value = !!sym(labels),
file = 'tool.choices') %>%
select(rownames,column,value,issue,file) %>%
mutate(priority = 'Second priority')
}else{label_issues <- data.frame()}
processed_data <- bind_rows(other_checks,add.space,non_eng,check_rel,check_con,
dupl_choices,check_con,check_rel,non_check,label_issues) %>%
relocate(file) %>%
mutate(rownames = as.numeric(rownames)+1)
if(all(is.na(processed_data$cyrillic_char))){
processed_data <- processed_data %>% select(-cyrillic_char)
}
output$resultTable <- renderDT({
DT::datatable(
processed_data,
filter = "top",
extensions = 'Buttons',
options = list(
dom = 'lfrtipB',
buttons = c("copy", "csv", "pdf"),
pageLength = 100,
scrollX=TRUE,
autoWidth = TRUE
)
)
})
}
})
output$name_selector <-  renderUI({
req(!is.null(data.tool()))
names_list <-  data.tool() %>% filter(grepl('select_',type)) %>% pull(name)
selectizeInput(
inputId = "question_name",
label = "Enter Question Name",
choices = names_list,
multiple = F,
width = "100%",
options = list(
'plugins' = list('remove_button'),
'create' = TRUE,
'persist' = TRUE
)
)
})
observeEvent(input$question_name, {
if (!is.null(data.tool())) {
questions <- get.relevanse.question(data.tool())
question_name <- input$question_name
if (question_name %in% questions$ref.name) {
tree_data <- build_tree(questions, question_name)
tree_data <- tibble(
name = input$question_name,
children = list(tree_data)
)
matrix_data <- build_matrix(questions, question_name, 0)
output$tree_chart <- renderEcharts4r({
tree_data %>%
e_charts() %>%
e_tree(orient = "RL", label = list(normal = list(position = "outside")), initialTreeDepth = 5)
})
output$matrix_table <- renderTable({
matrix_data
})
} else {
tree_data <- tibble(
name = "question wasn't found in the survey",
)
output$tree_chart <- renderEcharts4r({
tree_data %>%
e_charts() %>%
e_tree(orient = "RL", label = list(normal = list(position = "outside")), initialTreeDepth = 5)
})
}
}
})
}
# Run the app
shinyApp(ui, server)
runApp('Kobo_checker.R')
runApp('Kobo_checker.R')
runApp('Kobo_checker.R')
runApp('Kobo_checker.R')
runApp('Kobo_checker.R')
runApp('Kobo_checker.R')
runApp('Kobo_checker.R')
setwd(dirname(rstudioapi::getActiveDocumentContext()$path))
rm(list = ls())
directory_dictionary <- list(
research_cycle_name = 'XXX',
round = 'XXX',
dir.audits = "data/inputs/audits/reach/", # The directory to your audit files
dir.audits.check = "output/checking/audit/",# The directory to your audit summary files (you'll be checking these)
dir.requests = "output/checking/requests/", # the directory of your other_requests file
dir.responses = "output/checking/responses/", # the directory of your responses to open questions
enum_colname = "XXX", # the column that contains the enumerator ID,
enum_comments = 'XXX', # the column that contains the enumerator's comments,
filename.tool = "resources/MSNA_2023_Questionnaire_Final_CATI_cleaned.xlsx", # the name of your Kobo tool and its path
data_name = "XXXX.xlsx", # the name of your dataframe
data_path = "data/inputs/kobo_export/", # the path to your dataframe
label_colname = 'label::English', # the name of your label column. Has to be identical in Kobo survey and choices sheets
dctime_short = "XXXX" # the data of your survey (just for naming)
)
api_key <- source('resources/microsoft.api.key_regional.R')$value
#-------------------------------Initialize packages, load tools -----------------------------
source("src/init.R")
# load a single raw Kobo data export:
# and loads the data into kobo.raw.main, kobo.raw.loop1...
# also included are the standard steps of renaming uuid, and adding the loop_index
raw_data_filename <- list.files(directory_dictionary$data_path, full.names = T)
if(length(raw_data_filename) > 1) { stop("Found multiple files containing raw Kobo data! Please clean up the kobo_export folder.")
}else if(length(raw_data_filename) == 0){
warning("Raw Kobo data not found!")
kobo.raw.main <- data.frame()
kobo.raw.loop1 <- data.frame()
dataset_creation_time <- NA
dctime_short <- ""
}else if(length(raw_data_filename) == 1){
ls <- excel_sheets(path = raw_data_filename)
sheet_names <- if(length(ls)>1){
c('kobo.raw.main',paste0('kobo.raw.loop',1:(length(ls)-1)))
}else{
'kobo.raw.main'
}
for(i in 1:length(ls)){
if(i==1){
kobo.raw.main <- readxl::read_xlsx(raw_data_filename, col_types = "text", sheet = ls[i])
}else{
txt <- paste0(sheet_names[i],'=readxl::read_xlsx(raw_data_filename, col_types = "text", sheet = "',ls[i],'")%>%
mutate(loop_index = paste0("loop',i-1,'_", loop_index))'
)
eval(parse(text = txt))
}
}
dataset_creation_time <- as.Date(file.info(raw_data_filename)$ctime)
dctime_short <- str_extract(gsub('-', '', str_sub(dataset_creation_time, 3)), "\\d+")
}
rm(raw_data_filename)
raw.main <- kobo.raw.main
sheet_names <- sheet_names[sheet_names!='kobo.raw.main']
sheet_names_new <- gsub('kobo.','',sheet_names)
if(length(sheet_names_new)>0){
for(i in 1:length(sheet_names_new)){
txt <- paste0(sheet_names_new[i],' <- ',sheet_names[i])
eval(parse(text=txt))
}
}
# If there were any changes in the tool during data collection, they can be run here
source('src/sections/tool_modification.R')
# select the columns in your data that contain date elements
date_cols_main <- c("start","end", tool.survey %>% filter(type == "date" & datasheet == "main") %>% pull(name),
"submission_time") # add them here
# transform them into the datetime format
raw.main <- raw.main %>%
mutate_at(date_cols_main, ~ifelse(!str_detect(., '-'), as.character(convertToDateTime(as.numeric(.))), .))
rm(date_cols_main)
# specify the number of standard deviations you want to use
n.sd <- 3
# specify methods for  detecting outliers
method <- "o1"
# ignore 0 values or not
ignore_0 <- T
# specify columns for check or leave them empty
cols.integer_raw.main <- c()
cols.integer_raw.loop1 <- c()
cols.integer_raw.loop2 <- c()
cols.integer_raw.loop3 <- c()
source('src/sections/section_6_detect_and_visualise_outliers.R')
cleaning.log.outliers
wb <- createWorkbook()
addWorksheet(wb, 'Sheet 1')
writeDataTable(wb, sheet = 1, x = cleaning.log.outliers)
validate <- c("value corrected","value checked")
which(names(cleaning.log.outliers)=='checked')
names(cleaning.log.outliers)=='checked'
cleaning.log.outliers$checked <- NA
names(cleaning.log.outliers)=='checked'
which(names(cleaning.log.outliers)=='checked'), type = 'list', value = validate)
dataValidation(wb, 1, col = which(names(cleaning.log.outliers)=='checked'), type = 'list', value = validate)
help(dataValidation)
dataValidation(wb, 1, rows = 2:(nrow(cleaning.log.outliers)+1),
col = which(names(cleaning.log.outliers)=='checked'), type = 'list', value = validate)
validate
validate <- list("value corrected","value checked")
dataValidation(wb, 1, rows = 2:(nrow(cleaning.log.outliers)+1),
col = which(names(cleaning.log.outliers)=='checked'), type = 'list', value = validate)
wb <- createWorkbook()
addWorksheet(wb, 'Sheet 1')
writeDataTable(wb, sheet = 1, x = cleaning.log.outliers)
validate <- list("value corrected","value checked")
saveWorkbook(wb, 'dataValidationExample.xlsx', overwrite = T)
validate <- data.frame(values= c"value corrected","value checked"))
wb <- createWorkbook()
addWorksheet(wb, 'Sheet 1')
writeDataTable(wb, sheet = 1, x = cleaning.log.outliers)
validate <- data.frame(values= c("value corrected","value checked"))
writeData(wb, sheet = "Drop-down values", x = validate, startCol =
1)
addWorksheet(wb, 'Drop-down values')
writeData(wb, sheet = "Drop-down values", x = validate, startCol =
1)
wb <- createWorkbook()
addWorksheet(wb, 'Sheet 1')
addWorksheet(wb, 'Drop-down values')
validate <- data.frame(values= c("value corrected","value checked"))
writeData(wb, sheet = "Drop-down values", x = validate, startCol = 1)
writeDataTable(wb, sheet = 1, x = cleaning.log.outliers)
dataValidation(wb, 1, rows = 2:(nrow(cleaning.log.outliers)+1),
col = which(names(cleaning.log.outliers)=='checked'),
type = 'list', value = "'Drop-down values'!$A$2:$A$3")
saveWorkbook(wb, paste0("output/checking/outliers/outlier_analysis_", n.sd, "sd.xlsx"), overwrite=T, overwrite = T)
saveWorkbook(wb, paste0("output/checking/outliers/outlier_analysis_", n.sd, "sd.xlsx"), overwrite = T)
knitr::opts_chunk$set(echo = TRUE)
cleaning.log.outliers <- read.xlsx(paste0("output/checking/outliers/outlier_analysis_", n.sd, "sd.xlsx"),
sheet = 1)
cleaning.log.outliers <- cleaning.log.outliers %>% filter(checked%==%'value corrected')
make.filename.xlsx("output/Cleaning_logbook", "Cleaning_logbook")
