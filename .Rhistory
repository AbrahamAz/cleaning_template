datasheets
if(length(ls)>1){
txt <- paste0(
'datasheets_anon <-list("main" =raw.main,',
paste0('"',ls_loops,'" = ',sheet_names_new, collapse = ','),')'
)}else{
txt <- 'datasheets <-list("main" =raw.main)'
}
eval(parse(text= txt))
write.xlsx(datasheets_anon, make.filename.xlsx("output/final", "final_anonymized_data"), overwrite = T,
zoom = 90, firstRow = T)
setwd(dirname(rstudioapi::getActiveDocumentContext()$path))
пс()
gc()
setwd(dirname(rstudioapi::getActiveDocumentContext()$path))
rm(list = ls())
directory_dictionary <- list(
dir.audits = "data/inputs/audits/reach/", # The directory to your audit files
dir.audits.check = "output/checking/audit/",# The directory to your audit summary files (you'll be checking these)
dir.requests = "output/checking/requests/", # the directory of your other_requests file
dir.responses = "output/checking/responses/", # the directory of your responses to open questions
enum_colname = "enumerator_id", # the column that contains the enumerator ID,
enum_comments = 'enum_comms', # the column that contains the enumerator's comments,
filename.tool = "resources/Reach_UKR2306_CCCM_DS_tool_r2_v3 1.xlsx", # the name of your Kobo tool and its path
data_name = "Reach_UKR2306_CCCM_DS_tool_r2_-_all_versions_-_False_-_2023-11-25-09-58-22 (1).xlsx", # the name of your dataframe
data_path = "data/inputs/kobo_export/", # the path to your dataframe
label_colname = 'label::English', # the name of your label column. Has to be identical in Kobo survey and choices sheets
dctime_short = "2023_01_01" # the data of your survey (just for naming)
)
api_key <- source('resources/microsoft.api.key_regional.R')$value
#-------------------------------Initialize packages, load tools -----------------------------
source("src/init.R")
source("src/load_Data.R")
## Section below only for research cycles that requires cleaning on regular basis and use one kobo server.
cat(paste0("Section below only for research cycles that requires cleaning on regular basis and use one kobo server."))
# Run if you have any old files that need to be loaded and removed from the final dataframe
source('src/sections/process_old_data.R')
raw.main <- kobo.raw.main
sheet_names <- sheet_names[sheet_names!='kobo.raw.main']
sheet_names_new <- gsub('kobo.','',sheet_names)
if(length(sheet_names_new)>0){
for(i in 1:length(sheet_names_new)){
txt <- paste0(sheet_names_new[i],' <- ',sheet_names[i])
eval(parse(text=txt))
}
}
# If there were any changes in the tool during data collection, they can be run here
source('src/sections/tool_modification.R')
# select the columns in your data that contain date elements
date_cols_main <- c("start","end", tool.survey %>% filter(type == "date" & datasheet == "main") %>% pull(name),
"submission_time") # add them here
# transform them into the datetime format
raw.main <- raw.main %>%
mutate_at(date_cols_main, ~ifelse(!str_detect(., '-'), as.character(convertToDateTime(as.numeric(.))), .))
rm(date_cols_main)
source('src/sections/section_1_remove_duplicates_no_consents.R')
deletion.log.new
# get all of the other questions
other.db <- utilityR::get.other.db(tool.choices = tool.choices,
tool.survey = tool.survey,
label_colname = label_colname)
# Separate the other questions files by loop
other.db.main  <- other.db[other.db$name %in% colnames(raw.main),]
# find _other responses in main
other.responses <- utilityR::find.responses(raw.main, other.db.main)
other.responses <- raw.main %>%
select(uuid,all_of(na.omit(other.responses$ref.name))) %>%
pivot_longer(cols =all_of(na.omit(other.responses$ref.name)), names_to = 'ref.name', values_to = 'selected.ref.value') %>%
right_join(other.responses)
if(exists('raw.loop1')){
other.db.loop1 <- other.db[other.db$name %in% colnames(raw.loop1),]
other.responses.loop1 <- utilityR::find.responses(raw.loop1, other.db.loop1, is.loop = T)
if(nrow(other.responses.loop1)>0){
other.responses.loop1 <- raw.loop1 %>%
select(loop_index,all_of(na.omit(other.responses.loop1$ref.name))) %>%
pivot_longer(cols =all_of(na.omit(other.responses.loop1$ref.name)), names_to = 'ref.name', values_to = 'selected.ref.value') %>%
right_join(other.responses.loop1)
}else{other.responses.loop1<- data.frame()}
}else{other.responses.loop1 <- data.frame()}
if(exists('raw.loop2')){
other.db.loop2 <- other.db[other.db$name %in% colnames(raw.loop2),]
other.responses.loop2 <- utilityR::find.responses(raw.loop2, other.db.loop2, is.loop = T)
if(nrow(other.responses.loop2)>0){
other.responses.loop2 <- raw.loop2 %>%
select(loop_index,all_of(na.omit(other.responses.loop2$ref.name))) %>%
pivot_longer(cols =all_of(na.omit(other.responses.loop2$ref.name)), names_to = 'ref.name', values_to = 'selected.ref.value') %>%
right_join(other.responses.loop2)
}else{other.responses.loop2<- data.frame()}
}else{other.responses.loop2 <- data.frame()}
if(exists('raw.loop3')){
other.db.loop3 <- other.db[other.db$name %in% colnames(raw.loop3),]
other.responses.loop3 <- utilityR::find.responses(raw.loop3, other.db.loop3, is.loop = T)
if(nrow(other.responses.loop3)>0){
other.responses.loop3 <- raw.loop3 %>%
select(loop_index,all_of(na.omit(other.responses.loop3$ref.name))) %>%
pivot_longer(cols =all_of(na.omit(other.responses.loop3$ref.name)), names_to = 'ref.name', values_to = 'selected.ref.value') %>%
right_join(other.responses.loop3)
}else{other.responses.loop3<- data.frame()}
}else{other.responses.loop3 <- data.frame()}
other.responses.loop2
other.responses.loop1
# translate all text questions, but skip these columns:
trans_cols_to_skip <- c(
# add columns to skip
"enum_comms"
)
trans.db <- utilityR::get.trans.db(tool.choices = tool.choices,
tool.survey = tool.survey,
label_colname = label_colname) %>%
filter(!name %in% trans_cols_to_skip)
# if there are any variables that have text columns and are missing from trans DB - add them here
missing_vars <- data.frame(name = c('conditions_to_pursue_option_other',
'reasons_feeling_of_safety_non_idp_other'),
label = c('c2_6 [Space to expand or add further information given on reasons behind wanting to STAY or LEAVE their current CS]',
'd1_2 [Space to expand or add further information given on reasons why they feel safe or not]'))
trans.db <- rbind(trans.db, missing_vars)
# separate all open questions by loop and locate the answers to these questions
trans.db.main <- trans.db[trans.db$name %in% colnames(raw.main),]
trans.responses.main <- utilityR::find.responses(raw.main, trans.db.main)
if(exists('raw.loop1')){
trans.db.loop1 <- trans.db[trans.db$name %in% colnames(raw.loop1),]
if(nrow(trans.db.loop1)>0){
trans.responses.loop1 <- utilityR::find.responses(raw.loop1, trans.db.loop1, is.loop = T)
}else{trans.responses.loop1 <- data.frame()}
}else{trans.responses.loop1 <- data.frame()}
trans.responses.loop1
if(exists('raw.loop2')){
trans.db.loop2 <- trans.db[trans.db$name %in% colnames(raw.loop2),]
if(nrow(trans.db.loop2)>0){
trans.responses.loop2 <- utilityR::find.responses(raw.loop2, trans.db.loop2, is.loop = T)
}else{trans.responses.loop2 <- data.frame()}
}else{trans.responses.loop2 <- data.frame()}
if(exists('raw.loop3')){
trans.db.loop3 <- trans.db[trans.db$name %in% colnames(raw.loop3),]
if(nrow(trans.db.loop3)>0){
trans.responses.loop3 <- utilityR::find.responses(raw.loop3, trans.db.loop3, is.loop = T)
}else{trans.responses.loop3 <- data.frame()}
}else{trans.responses.loop3 <- data.frame()}
# bind them all together
trans.responses <- rbind(trans.responses.main,
trans.responses.loop1,
trans.responses.loop2,
trans.responses.loop3)
rm(trans.responses.main, trans.responses.loop1, trans.db.loop2, trans.responses.loop3)
source('src/sections/section_4_create_other_requests_files.R')
# get all of the other questions
other.db <- utilityR::get.other.db(tool.choices = tool.choices,
tool.survey = tool.survey,
label_colname = label_colname)
# Separate the other questions files by loop
other.db.main  <- other.db[other.db$name %in% colnames(raw.main),]
# find _other responses in main
other.responses <- utilityR::find.responses(raw.main, other.db.main)
other.responses <- raw.main %>%
select(uuid,all_of(na.omit(other.responses$ref.name))) %>%
pivot_longer(cols =all_of(na.omit(other.responses$ref.name)), names_to = 'ref.name', values_to = 'selected.ref.value') %>%
right_join(other.responses)
if(exists('raw.loop1')){
other.db.loop1 <- other.db[other.db$name %in% colnames(raw.loop1),]
other.responses.loop1 <- utilityR::find.responses(raw.loop1, other.db.loop1, is.loop = T)
if(nrow(other.responses.loop1)>0){
other.responses.loop1 <- raw.loop1 %>%
select(loop_index,all_of(na.omit(other.responses.loop1$ref.name))) %>%
pivot_longer(cols =all_of(na.omit(other.responses.loop1$ref.name)), names_to = 'ref.name', values_to = 'selected.ref.value') %>%
right_join(other.responses.loop1)
}else{other.responses.loop1<- data.frame()}
}else{other.responses.loop1 <- data.frame()}
if(exists('raw.loop2')){
other.db.loop2 <- other.db[other.db$name %in% colnames(raw.loop2),]
other.responses.loop2 <- utilityR::find.responses(raw.loop2, other.db.loop2, is.loop = T)
if(nrow(other.responses.loop2)>0){
other.responses.loop2 <- raw.loop2 %>%
select(loop_index,all_of(na.omit(other.responses.loop2$ref.name))) %>%
pivot_longer(cols =all_of(na.omit(other.responses.loop2$ref.name)), names_to = 'ref.name', values_to = 'selected.ref.value') %>%
right_join(other.responses.loop2)
}else{other.responses.loop2<- data.frame()}
}else{other.responses.loop2 <- data.frame()}
if(exists('raw.loop3')){
other.db.loop3 <- other.db[other.db$name %in% colnames(raw.loop3),]
other.responses.loop3 <- utilityR::find.responses(raw.loop3, other.db.loop3, is.loop = T)
if(nrow(other.responses.loop3)>0){
other.responses.loop3 <- raw.loop3 %>%
select(loop_index,all_of(na.omit(other.responses.loop3$ref.name))) %>%
pivot_longer(cols =all_of(na.omit(other.responses.loop3$ref.name)), names_to = 'ref.name', values_to = 'selected.ref.value') %>%
right_join(other.responses.loop3)
}else{other.responses.loop3<- data.frame()}
}else{other.responses.loop3 <- data.frame()}
# bind them all together
other.responses <- rbind(other.responses, other.responses.loop1, other.responses.loop2, other.responses.loop3)
other.responses
# translate all text questions, but skip these columns:
trans_cols_to_skip <- c(
# add columns to skip
"enum_comms"
)
trans.db <- utilityR::get.trans.db(tool.choices = tool.choices,
tool.survey = tool.survey,
label_colname = label_colname) %>%
filter(!name %in% trans_cols_to_skip)
# if there are any variables that have text columns and are missing from trans DB - add them here
missing_vars <- data.frame(name = c('conditions_to_pursue_option_other',
'reasons_feeling_of_safety_non_idp_other'),
label = c('c2_6 [Space to expand or add further information given on reasons behind wanting to STAY or LEAVE their current CS]',
'd1_2 [Space to expand or add further information given on reasons why they feel safe or not]'))
trans.db <- rbind(trans.db, missing_vars)
# separate all open questions by loop and locate the answers to these questions
trans.db.main <- trans.db[trans.db$name %in% colnames(raw.main),]
trans.responses.main <- utilityR::find.responses(raw.main, trans.db.main)
trans.responses.main
if(exists('raw.loop1')){
trans.db.loop1 <- trans.db[trans.db$name %in% colnames(raw.loop1),]
if(nrow(trans.db.loop1)>0){
trans.responses.loop1 <- utilityR::find.responses(raw.loop1, trans.db.loop1, is.loop = T)
}else{trans.responses.loop1 <- data.frame()}
}else{trans.responses.loop1 <- data.frame()}
trans.db.loop1
trans.responses.main
nrow(trans.db.loop1)>0
trans.responses.loop1 <- utilityR::find.responses(raw.loop1, trans.db.loop1, is.loop = T)
trans.responses.loop1
if(exists('raw.loop1')){
trans.db.loop1 <- trans.db[trans.db$name %in% colnames(raw.loop1),]
if(nrow(trans.db.loop1)>0){
trans.responses.loop1 <- utilityR::find.responses(raw.loop1, trans.db.loop1, is.loop = T)
}else{trans.responses.loop1 <- data.frame()}
}else{trans.responses.loop1 <- data.frame()}
trans.responses.loop1
code_for_check  <- c('99','999')
source('src/sections/section_5_create_999_checks.R')
# if Anything got into cl_log_999, check it. If you want to delete it from your data run the command below
source('src/sections/section_5_finish_999_checks.R')
print(cl_log_999)
cl_log_999
#############################################################################################################
# 5) Outliers
#############################################################################################################
# save.image(file = "Environment.RData")
# load("Environment.RData")
n.sd <- 3
# specify methods for  detecting outliers
method <- "o1"
# ignore 0 values or not
ignore_0 <- T
# specify columns for check or leave them empty
cols.integer_raw.main <- c()
cols.integer_raw.loop1 <- c()
cols.integer_raw.loop2 <- c()
cols.integer_raw.loop3 <- c()
source('src/sections/section_6_detect_and_visualise_outliers.R')
cleaning.log.outliers
# specify methods for  detecting outliers
method <- "o2"
source('src/sections/section_6_detect_and_visualise_outliers.R')
cleaning.log.outliers
# specify methods for  detecting outliers
method <- "o3"
source('src/sections/section_6_detect_and_visualise_outliers.R')
cleaning.log.outliers
gc()
setwd(dirname(rstudioapi::getActiveDocumentContext()$path))
rm(list = ls())
directory_dictionary <- list(
dir.audits = "data/inputs/audits/reach/", # The directory to your audit files
dir.audits.check = "output/checking/audit/",# The directory to your audit summary files (you'll be checking these)
dir.requests = "output/checking/requests/", # the directory of your other_requests file
dir.responses = "output/checking/responses/", # the directory of your responses to open questions
enum_colname = "enumerator_id", # the column that contains the enumerator ID,
enum_comments = 'enum_comms', # the column that contains the enumerator's comments,
filename.tool = "resources/MSNA_2023_Questionnaire_Final_CATI_cleaned.xlsx", # the name of your Kobo tool and its path
data_name = "UKR2308_MSNA_2023_F2F_raw_dataset.xlsx", # the name of your dataframe
data_path = "data/inputs/kobo_export/", # the path to your dataframe
label_colname = 'label::English', # the name of your label column. Has to be identical in Kobo survey and choices sheets
dctime_short = "2023_01_01" # the data of your survey (just for naming)
)
api_key <- source('resources/microsoft.api.key_regional.R')$value
#-------------------------------Initialize packages, load tools -----------------------------
source("src/init.R")
source("src/load_Data.R")
unzip('C:\Users\reach\Desktop\Git\cleaning_template\data\inputs\kobo_export\UKR2308_MSNA_2023_F2F_raw_dataset.xlsx')
raw_data_filename
excel_sheets(path = raw_data_filename)
source("src/load_Data.R")
## Section below only for research cycles that requires cleaning on regular basis and use one kobo server.
cat(paste0("Section below only for research cycles that requires cleaning on regular basis and use one kobo server."))
raw.main <- kobo.raw.main
sheet_names <- sheet_names[sheet_names!='kobo.raw.main']
sheet_names_new <- gsub('kobo.','',sheet_names)
if(length(sheet_names_new)>0){
for(i in 1:length(sheet_names_new)){
txt <- paste0(sheet_names_new[i],' <- ',sheet_names[i])
eval(parse(text=txt))
}
}
# select the columns in your data that contain date elements
date_cols_main <- c("start","end", tool.survey %>% filter(type == "date" & datasheet == "main") %>% pull(name),
"submission_time") # add them here
# transform them into the datetime format
raw.main <- raw.main %>%
mutate_at(date_cols_main, ~ifelse(!str_detect(., '-'), as.character(convertToDateTime(as.numeric(.))), .))
rm(date_cols_main)
source('src/sections/section_1_remove_duplicates_no_consents.R')
raw.main$enum_id_cccm
raw.main$enum_id_cccm %>% table()
raw.main$enum_id_msna_f2f %>% table()
raw.main$enum_office_msna_f2f %>% table()
raw.main$enum_col <- ifelse(is.na(raw.main$enum_id_msna_f2f),raw.main$enum_id_msna_cati,raw.main$enum_id_msna_f2f)
is.na(raw.main$enum_col) %>% table()
raw.main$enum_col <- ifelse(is.na(raw.main$enum_col),raw.main$enum_id_cccm,raw.main$enum_col)
is.na(raw.main$enum_col) %>% table()
source('src/sections/section_1_remove_duplicates_no_consents.R')
raw.main$N_1_enumerator_comment_note
directory_dictionary <- list(
dir.audits = "data/inputs/audits/reach/", # The directory to your audit files
dir.audits.check = "output/checking/audit/",# The directory to your audit summary files (you'll be checking these)
dir.requests = "output/checking/requests/", # the directory of your other_requests file
dir.responses = "output/checking/responses/", # the directory of your responses to open questions
enum_colname = "enum_col", # the column that contains the enumerator ID,
enum_comments = 'N_1_enumerator_comment_note', # the column that contains the enumerator's comments,
filename.tool = "resources/MSNA_2023_Questionnaire_Final_CATI_cleaned.xlsx", # the name of your Kobo tool and its path
data_name = "UKR2308_MSNA_2023_F2F_raw_dataset.xlsx", # the name of your dataframe
data_path = "data/inputs/kobo_export/", # the path to your dataframe
label_colname = 'label::English', # the name of your label column. Has to be identical in Kobo survey and choices sheets
dctime_short = "2023_01_01" # the data of your survey (just for naming)
)
source('src/sections/section_1_remove_duplicates_no_consents.R')
# get all of the other questions
other.db <- utilityR::get.other.db(tool.choices = tool.choices,
tool.survey = tool.survey,
label_colname = label_colname)
# Separate the other questions files by loop
other.db.main  <- other.db[other.db$name %in% colnames(raw.main),]
# find _other responses in main
other.responses <- utilityR::find.responses(raw.main, other.db.main)
other.responses <- raw.main %>%
select(uuid,all_of(na.omit(other.responses$ref.name))) %>%
pivot_longer(cols =all_of(na.omit(other.responses$ref.name)), names_to = 'ref.name', values_to = 'selected.ref.value') %>%
right_join(other.responses)
if(exists('raw.loop1')){
other.db.loop1 <- other.db[other.db$name %in% colnames(raw.loop1),]
other.responses.loop1 <- utilityR::find.responses(raw.loop1, other.db.loop1, is.loop = T)
if(nrow(other.responses.loop1)>0){
other.responses.loop1 <- raw.loop1 %>%
select(loop_index,all_of(na.omit(other.responses.loop1$ref.name))) %>%
pivot_longer(cols =all_of(na.omit(other.responses.loop1$ref.name)), names_to = 'ref.name', values_to = 'selected.ref.value') %>%
right_join(other.responses.loop1)
}else{other.responses.loop1<- data.frame()}
}else{other.responses.loop1 <- data.frame()}
if(exists('raw.loop2')){
other.db.loop2 <- other.db[other.db$name %in% colnames(raw.loop2),]
other.responses.loop2 <- utilityR::find.responses(raw.loop2, other.db.loop2, is.loop = T)
if(nrow(other.responses.loop2)>0){
other.responses.loop2 <- raw.loop2 %>%
select(loop_index,all_of(na.omit(other.responses.loop2$ref.name))) %>%
pivot_longer(cols =all_of(na.omit(other.responses.loop2$ref.name)), names_to = 'ref.name', values_to = 'selected.ref.value') %>%
right_join(other.responses.loop2)
}else{other.responses.loop2<- data.frame()}
}else{other.responses.loop2 <- data.frame()}
if(exists('raw.loop3')){
other.db.loop3 <- other.db[other.db$name %in% colnames(raw.loop3),]
other.responses.loop3 <- utilityR::find.responses(raw.loop3, other.db.loop3, is.loop = T)
if(nrow(other.responses.loop3)>0){
other.responses.loop3 <- raw.loop3 %>%
select(loop_index,all_of(na.omit(other.responses.loop3$ref.name))) %>%
pivot_longer(cols =all_of(na.omit(other.responses.loop3$ref.name)), names_to = 'ref.name', values_to = 'selected.ref.value') %>%
right_join(other.responses.loop3)
}else{other.responses.loop3<- data.frame()}
}else{other.responses.loop3 <- data.frame()}
# bind them all together
other.responses <- rbind(other.responses, other.responses.loop1, other.responses.loop2, other.responses.loop3)
View(other.responses)
# translate all text questions, but skip these columns:
trans_cols_to_skip <- c(
# add columns to skip
"enum_comms"
)
trans.db <- utilityR::get.trans.db(tool.choices = tool.choices,
tool.survey = tool.survey,
label_colname = label_colname) %>%
filter(!name %in% trans_cols_to_skip)
# separate all open questions by loop and locate the answers to these questions
trans.db.main <- trans.db[trans.db$name %in% colnames(raw.main),]
trans.responses.main <- utilityR::find.responses(raw.main, trans.db.main)
if(exists('raw.loop1')){
trans.db.loop1 <- trans.db[trans.db$name %in% colnames(raw.loop1),]
if(nrow(trans.db.loop1)>0){
trans.responses.loop1 <- utilityR::find.responses(raw.loop1, trans.db.loop1, is.loop = T)
}else{trans.responses.loop1 <- data.frame()}
}else{trans.responses.loop1 <- data.frame()}
if(exists('raw.loop2')){
trans.db.loop2 <- trans.db[trans.db$name %in% colnames(raw.loop2),]
if(nrow(trans.db.loop2)>0){
trans.responses.loop2 <- utilityR::find.responses(raw.loop2, trans.db.loop2, is.loop = T)
}else{trans.responses.loop2 <- data.frame()}
}else{trans.responses.loop2 <- data.frame()}
if(exists('raw.loop3')){
trans.db.loop3 <- trans.db[trans.db$name %in% colnames(raw.loop3),]
if(nrow(trans.db.loop3)>0){
trans.responses.loop3 <- utilityR::find.responses(raw.loop3, trans.db.loop3, is.loop = T)
}else{trans.responses.loop3 <- data.frame()}
}else{trans.responses.loop3 <- data.frame()}
# bind them all together
trans.responses <- rbind(trans.responses.main,
trans.responses.loop1,
trans.responses.loop2,
trans.responses.loop3)
View(trans.responses)
# name that hosts the clean recode.others file, leave as '' if you don't have this file. Nothing will be recoded that way
name_clean_others_file <- 'UKR2308_MSNA_other_response_230802'
sheet_name_others <- 'Sheet2' # name of the sheet where you're holding your requests
# name that hosts the clean translation requests file, leave as '' if you don't have this file. Nothing will be recoded that way
name_clean_trans_file <- 'MSNA_UKR_translate_response'
or.edited  <- utilityR::load.requests(directory_dictionary$dir.requests,
name_clean_others_file,
sheet = sheet_name_others, validate = T)  # specify Sheet2 because the first one is a readme
View(or.edited)
if(any(or.edited$check == 1)){
issue <- paste0('uuid: ', or.edited[or.edited$check == 1,]$uuid,', variable: ',or.edited[or.edited$check == 1,]$name)
stop(paste0('Some of your entries have errors, please double-check: ', paste0(issue,collapse = '\n')))
}
if(any(or.edited$check == 3)){
issue <- paste0('uuid: ', or.edited[or.edited$check == 3,]$uuid,', variable: ',or.edited[or.edited$check == 3,]$name)
stop(paste0('Some of your entries are empty, please double-check: ', paste0(issue,collapse = '\n')))
}
# separate the other translations to fit each individual dataframe that you have - no unnecessary variables in each
raw.main_requests <- or.edited %>%
filter(name %in% names(raw.main))
if(exists('raw.loop1')){
raw.loop1_requests <- or.edited %>%
filter(name %in% names(raw.loop1))
if(nrow(raw.loop1_requests)==0){
rm(raw.loop1_requests)
}
}
if(exists('raw.loop2')){
raw.loop2_requests <- or.edited %>%
filter(name %in% names(raw.loop2))
if(nrow(raw.loop2_requests)==0){
rm(raw.loop2_requests)
}
}
if(exists('raw.loop3')){
raw.loop3_requests <- or.edited %>%
filter(name %in% names(raw.loop3))
if(nrow(raw.loop3_requests)==0){
rm(raw.loop3_requests)
}
}
# Create a cleaning log file for each loop if there's a need for it.
cleaning.log.other.main <- utilityR::recode.others(data = raw.main,
or.edited = raw.main_requests,
orig_response_col = 'responses',
is.loop = F,
tool.choices = tool.choices,
tool.survey = tool.survey)
raw.main_requests
# Create a cleaning log file for each loop if there's a need for it.
cleaning.log.other.main <- utilityR::recode.others(data = raw.main,
or.edited = raw.main_requests,
orig_response_col = 'response.uk',
is.loop = F,
tool.choices = tool.choices,
tool.survey = tool.survey)
View(tool.choices)
#-------------------------------Initialize packages, load tools -----------------------------
source("src/init.R")
# Create a cleaning log file for each loop if there's a need for it.
cleaning.log.other.main <- utilityR::recode.others(data = raw.main,
or.edited = raw.main_requests,
orig_response_col = 'response.uk',
is.loop = F,
tool.choices = tool.choices,
tool.survey = tool.survey)
raw.main$D_3_living_conditions_issues
raw.main_requests <- raw.main_requests[raw.main_requests$uuid %in% raw.main$uuid]
raw.main_requests <- raw.main_requests[raw.main_requests$uuid %in% raw.main$uuid,]
# Create a cleaning log file for each loop if there's a need for it.
cleaning.log.other.main <- utilityR::recode.others(data = raw.main,
or.edited = raw.main_requests,
orig_response_col = 'response.uk',
is.loop = F,
tool.choices = tool.choices,
tool.survey = tool.survey)
View(raw.main_requests)
gsub(';','',raw.main_requests$existing.v)
raw.main_requests$existing.v <- gsub(';','',raw.main_requests$existing.v)
# Create a cleaning log file for each loop if there's a need for it.
cleaning.log.other.main <- utilityR::recode.others(data = raw.main,
or.edited = raw.main_requests,
orig_response_col = 'response.uk',
is.loop = F,
tool.choices = tool.choices,
tool.survey = tool.survey)
View(raw.main_requests)
test <- raw.main_requests[raw.main_requests$ref.name=='D_3_living_conditions_issues',]
test
recode.others_select_multiple(data = raw.main,or.select_multiple = test,orig_response_col = 'response.uk',print_debug = T,
is.loop = T, tool.survey_others = tool.survey, tool.choices_others = tool.choices,
label_colname ='label::English'
)
test$uniqui <- test$uuid
recode.others_select_multiple(data = raw.main,or.select_multiple = test,orig_response_col = 'response.uk',print_debug = T,
is.loop = T, tool.survey_others = tool.survey, tool.choices_others = tool.choices,
label_colname ='label::English'
)
test$uniqui <- test$uuid
test.main <- raw.main
test.main$uniqui <- test.main$uuid
recode.others_select_multiple(data = test.main,or.select_multiple = test,orig_response_col = 'response.uk',print_debug = T,
is.loop = T, tool.survey_others = tool.survey, tool.choices_others = tool.choices,
label_colname ='label::English'
)
View(tool.choices)
