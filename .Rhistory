dir.requests = "output/checking/requests/", # the directory of your other_requests file
dir.responses = "output/checking/responses/", # the directory of your responses to open questions
enum_colname = "enum_id", # the column that contains the enumerator ID,
enum_comments = 'N_1_enumerator_comment_note', # the column that contains the enumerator's comments,
filename.tool = "resources/XXX.xlsx", # the name of your Kobo tool and its path
data_name = "XXXX.xlsx", # the name of your dataframe
data_path = "data/inputs/kobo_export/", # the path to your dataframe
label_colname = 'label::English', # the name of your label column. Has to be identical in Kobo survey and choices sheets
dctime_short = "XXXX" # the data of your survey (just for naming)
)
source('src/sections/section_1_remove_duplicates_no_consents.R')
min_duration_interview <- 5 # minimum duration of an interview (screen time in minutes)
max_duration_interview <- 60 # maximum duration of an interview (screen time in minutes)
pre_process_audit_files <- F # whether cases of respondent taking too long to answer 1 question should cleaned.
# if pre_process_audit_files =T, enter the maximum time that  the respondent can spend answering 1 question (in minutes)
max_length_answer_1_question <- 20
# Used during the check for soft duplicates.
# The minimum number of different columns that makes us confident that the entry is not a soft duplicate
min_num_diff_questions <- 8
# run the checks
source('src/sections/section_2_run_audit_checks.R')
#specify the column that holds the cordinates
geo_column <- ''
source('src/sections/section_3_loops_and_spatial_checks.R')
source('src/sections/section_3_spatial_decisions.R')
directory_dictionary$dir.audits.check
make.filename.xlsx(directory_dictionary$dir.audits.check, "geospatial_check")
make.filename.xlsx(directory_dictionary$dir.audits.check, "geospatial_check")
# name that hosts the clean recode.others file, leave as '' if you don't have this file. Nothing will be recoded that way
name_clean_others_file <- 'UKR2308_MSNA_other_response_230802.xlsx'
sheet_name_others <- 'Sheet2' # name of the sheet where you're holding your requests
cleaning.log <- data.frame()
or.edited  <- utilityR::load.requests(directory_dictionary$dir.requests,
name_clean_others_file,
sheet = sheet_name_others, validate = T)
directory_dictionary$dir.requests
# name that hosts the clean recode.others file, leave as '' if you don't have this file. Nothing will be recoded that way
name_clean_others_file <- 'UKR2308_MSNA_other_response_230802'
or.edited  <- utilityR::load.requests(directory_dictionary$dir.requests,
name_clean_others_file,
sheet = sheet_name_others, validate = T)
or.edited <- or.edited %>%
left_join(tool.survey %>% select(name,list_name) %>% rename(ref.name=name)) %>%
dplyr::rowwise() %>%
dplyr::mutate(existing.v.choice_label = sapply(stringr::str_split(choice, " "), function(choice_list) {
if (is.na(existing.v)) {
return("NA")
}
existing.v.list <- unlist(strsplit(existing.v, ";"))
for (ch in choice_list) {
if ((list_name %in% tool.choices$list_name)) {
label <- utilityR::get.choice.label(ch, list_name,
directory_dictionary$label_colname, tool.choices)
if ((is.element(label, existing.v.list))) {
existing.v.list <- existing.v.list[!existing.v.list %in% label]
}
} else {
stop(paste0("The choice list ", list_name, " does not exist in the tool.choices file"))
}
}
return(paste(existing.v.list, collapse = ";"))
})) %>%
dplyr::ungroup() %>%
mutate(existing.v = ifelse(existing.v.choice_label == '', NA, existing.v.choice_label),
invalid.v = ifelse(existing.v.choice_label == '', 'YES', invalid.v))
if(any(or.edited$check == 1)){
issue <- paste0('uuid: ', or.edited[or.edited$check == 1,]$uuid,
', variable: ',or.edited[or.edited$check == 1,]$name)
stop(paste0('Some of your entries have errors, please double-check: ',
paste0(issue,collapse = '\n')))
}
if(any(or.edited$check == 3)){
issue <- paste0('uuid: ', or.edited[or.edited$check == 3,]$uuid,
', variable: ',or.edited[or.edited$check == 3,]$name)
stop(paste0('Some of your entries are empty, please double-check: ',
paste0(issue,collapse = '\n')))
}
consistency_check <- or.edited %>% select(uuid, existing.v, ref.name) %>%
filter(!is.na(existing.v)) %>%
tidyr::separate_rows(existing.v  , sep= "[;\r\n]") %>%
mutate(existing.v = trimws(existing.v)) %>%
filter(!existing.v=='') %>%
left_join((tool.survey %>% select(name, list_name)), join_by(ref.name==name )) %>%
anti_join(tool.choices %>% select(list_name,directory_dictionary$label_colname) %>%
rename('existing.v'=directory_dictionary$label_colname))
if(nrow(consistency_check)>0){
stop("Some of the choices that you've selected in the recode.others
file do not match the labels that you have in your
tool. Please check the consistency_check object for more details")
}
# separate the other translations to fit each individual dataframe that you have - no unnecessary variables in each
raw.main_requests <- or.edited %>%
filter(name %in% names(raw.main))
if(exists('raw.loop1')){
raw.loop1_requests <- or.edited %>%
filter(name %in% names(raw.loop1))
if(nrow(raw.loop1_requests)==0){
rm(raw.loop1_requests)
}
}
if(exists('raw.loop2')){
raw.loop2_requests <- or.edited %>%
filter(name %in% names(raw.loop2))
if(nrow(raw.loop2_requests)==0){
rm(raw.loop2_requests)
}
}
if(exists('raw.loop3')){
raw.loop3_requests <- or.edited %>%
filter(name %in% names(raw.loop3))
if(nrow(raw.loop3_requests)==0){
rm(raw.loop3_requests)
}
}
# If you face any weird double spaces
tool.choices$`label::English`=str_squish(tool.choices$`label::English`)
tool.choices$name=str_squish(tool.choices$name)
cleaning.log.other.loop2 <- utilityR::recode.others(
data = raw.loop2,
or.edited = raw.loop2_requests,
orig_response_col = 'response.uk',
is.loop = T,
tool.choices = tool.choices,
tool.survey = tool.survey)
View(raw.loop2_requests)
View(cleaning.log.other.loop2)
test_sm <- function (data, or.select_multiple, orig_response_col = "response.uk",
print_debug = T, is.loop, tool.survey_others = tool.survey,
tool.choices_others = tool.choices, label_colname = "label::English",
CL_COLS = c("uuid", "uniqui", "loop_index", "variable",
"old.value", "new.value", "issue"))
{
if (!"uuid" %in% names(data) & is.loop) {
stop(print("Your loop data doesnt have the uuid variable, please check the data and rename uuid appropriately"))
}
if (any(!or.select_multiple$uniqui %in% data$uniqui)) {
cat(paste0("The following unique IDs from your requests file were not found in the data provided: ",
paste0(dplyr::setdiff(or.select_multiple$uniqui,
data$uniqui), collapse = ", "), ". Please double check "))
or.select_multiple <- or.select_multiple[or.select_multiple$uniqui %in%
data$uniqui, ]
}
or.select_multiple.remove <- dplyr::filter(or.select_multiple,
!is.na(invalid.v))
cl_sm_remove <- dplyr::tibble()
if (nrow(or.select_multiple.remove) > 0) {
if (print_debug) {
cat(paste("Number of invalid select_multiple responses:",
nrow(or.select_multiple.remove)), "\n")
}
variables <- or.select_multiple.remove %>% dplyr::select(ref.name,
name) %>% dplyr::distinct(ref.name, .keep_all = T)
for (variable in variables %>% dplyr::pull(ref.name)) {
thisvar_data <- data %>% dplyr::filter(uniqui %in%
(or.select_multiple.remove %>% dplyr::filter(ref.name ==
variable) %>% dplyr::pull(uniqui)))
other_variable <- variables$name[which(variables$ref.name ==
variable)]
cl_only_other <- thisvar_data %>% dplyr::filter(!!rlang::sym(variable) ==
"other") %>% recode.multiple.set.NA(variable,
"Invalid other response", other_var_name = other_variable,
CL_COLS = CL_COLS)
cl_notjust_other <- thisvar_data %>% dplyr::filter(!!rlang::sym(variable) !=
"other") %>% recode.multiple.remove.choices(variable,
"other", "Invalid other response", other_var_name = other_variable,
CL_COLS = CL_COLS)
cl_sm_remove <- dplyr::bind_rows(cl_sm_remove, cl_only_other,
cl_notjust_other)
}
}
or.select_multiple.recode <- or.select_multiple %>% dplyr::filter(!is.na(existing.v)) %>%
dplyr::mutate(list_name = sapply(ref.name, function(x) {
get.choice.list.from.name(x, tool.survey = tool.survey_others)
}), existing.v = stringr::str_split(stringr::str_squish(existing.v),
" *; *", simplify = T))
cl_sm_recode <- dplyr::tibble()
if (nrow(or.select_multiple.recode) > 0) {
if (print_debug) {
cat(paste("Number of select_multiple responses to be recoded:",
nrow(or.select_multiple.recode)), "\n")
}
choices_lookup <- tool.choices_others %>% dplyr::filter(list_name %in%
or.select_multiple.recode$list_name) %>% dplyr::rename(label = !!rlang::sym(label_colname),
choice_name = name)
for (r in 1:nrow(or.select_multiple.recode)) {
or.row <- or.select_multiple.recode[r, ]
data.row <- data %>% dplyr::filter(uniqui == or.row$uniqui)
chosen_labels <- or.row$existing.v[or.row$existing.v !=
"" & !is.na(or.row$existing.v)]
if (any(!chosen_labels %in% choices_lookup$label)) {
stop("Choice '", paste(chosen_labels[!chosen_labels %in%
choices_lookup$label], collapse = "' "), "' not found in list ",
or.row$list_name)
}
choices <- choices_lookup %>% dplyr::filter(list_name ==
or.row$list_name & label %in% chosen_labels) %>%
dplyr::pull(choice_name)
if (!is.na(or.row$true.v)) {
cl_sm_recode <- dplyr::bind_rows(cl_sm_recode,
or.row %>% dplyr::mutate(variable = name,
old.value = !!rlang::sym(orig_response_col),
new.value = true.v, issue = "Translating other response") %>%
dplyr::select(any_of(CL_COLS)))
cl_sm_recode_add_choice <- recode.multiple.add.choices(data.row,
or.row$ref.name, choices, "Recoding other response")
cl_sm_recode <- cl_sm_recode %>% dplyr::mutate_all(as.character)
cl_sm_recode_add_choice <- cl_sm_recode_add_choice %>%
dplyr::mutate_all(as.character)
cl_sm_recode <- dplyr::bind_rows(cl_sm_recode,
cl_sm_recode_add_choice)
}
else {
old_choices <- data.row[[or.row$ref.name]] %>%
stringr::str_split(" ", simplify = T)
choices <- c(choices, old_choices[old_choices !=
"other"])
or.row<<-or.row
data.row<<-data.row
choices<<-choices
cl_sm_recode_add_ch <- recode.multiple.set.choices(data.row,
or.row$ref.name, choices, "Recoding other response",
other_var_name = or.row$name, tool.survey = tool.survey_others,
tool.choices = tool.choices_others)
cl_sm_recode_add_ch <- cl_sm_recode_add_ch %>%
dplyr::mutate_all(as.character)
cl_sm_recode <- dplyr::bind_rows(cl_sm_recode,
cl_sm_recode_add_ch)
}
}
}
or.select_multiple.true <- or.select_multiple %>% dplyr::filter(!is.na(true.v) &
check == 2)
if (print_debug) {
cat(paste("Number of true select_multiple responses:",
nrow(or.select_multiple.true)), "\n")
}
cl_sm_true <- or.select_multiple.true %>% dplyr::mutate(variable = name,
old.value = !!rlang::sym(orig_response_col), new.value = true.v,
issue = "Translating other response") %>% dplyr::select(any_of(CL_COLS))
cl_sm_true <- cl_sm_true %>% dplyr::mutate_all(as.character)
cl_sm_remove <- cl_sm_remove %>% dplyr::mutate_all(as.character)
cl_sm_recode <- cl_sm_recode %>% dplyr::mutate_all(as.character)
result_fin <- dplyr::bind_rows(cl_sm_true, cl_sm_remove,
cl_sm_recode)
if (!is.loop & !"loop_index" %in% names(result_fin)) {
result_fin$loop_index <- NA_character_
}
return(result_fin)
}
raw.loop2
or.edited_sm <- or.edited %>% filter(loop_index=='loop2_26375')
or.edited_sm
sm_data <- raw.loop2 %>% dplyr::filter(loop_index %in% 'loop2_26375')
test_sm(
data=sm_data,or.select_multiple = or.edited_sm,orig_response_col = 'response.uk',is.loop = T,tool.survey_others = tool.survey,tool.choices_others = tool.choices,
label_colname = 'label::English'
)
or.edited_sm <- or.edited %>% filter(loop_index=='loop2_26375') %>% mutate(uniqui=loop_index)
sm_data <- raw.loop2 %>% dplyr::filter(loop_index %in% 'loop2_26375')%>% mutate(uniqui=loop_index)
test_sm(
data=sm_data,or.select_multiple = or.edited_sm,orig_response_col = 'response.uk',is.loop = T,tool.survey_others = tool.survey,tool.choices_others = tool.choices,
label_colname = 'label::English'
)
or.row
choices
recode.multiple.set.choices(data.row,
or.row$ref.name, choices, "Recoding other response",
other_var_name = or.row$name, tool.survey = tool.survey_others,
tool.choices = tool.choices_others)
recode.multiple.set.choices(data.row,
or.row$ref.name, choices, "Recoding other response",
other_var_name = or.row$name, tool.survey = tool.survey,
tool.choices = tool.choices)
choices
recode.multiple.set.choices(data.row,
or.row$ref.name, unique(choices), "Recoding other response",
other_var_name = or.row$name, tool.survey = tool.survey,
tool.choices = tool.choices)
unique(choices)
recode.multiple.set.choices(data.row,
or.row$ref.name, choices = unique(choices), "Recoding other response",
other_var_name = or.row$name, tool.survey = tool.survey,
tool.choices = tool.choices)
paste0(variable, "/", choices)
data <- data.row
variable <- or.row$ref.name,
issue <- 'test'
paste0(variable, "/", choices)
variable <- or.row$ref.name,
variable <- or.row$ref.name
choices <- unique(choices)
issue <- 'test'
paste0(variable, "/", choices)
choice_columns <- paste0(variable, "/", choices)
if (any(!choice_columns %in% colnames(data))) {
stop(paste("Columns", paste(choice_columns, collapse = ", "),
"not present in data!"))
}
ls_name <- get.choice.list.from.name(variable, tool.survey)
ls_name
newvalue <- tool.choices %>% dplyr::filter(list_name ==
ls_name & name %in% choices) %>% dplyr::pull(name) %>%
paste(collapse = " ")
newvalue
tool.choices
tool.choices %>% dplyr::filter(list_name ==
ls_name & name %in% choices)
tool.choices %>% dplyr::filter(list_name ==
ls_name & name %in% choices) %>% dplyr::pull(name)
tool.choices %>% dplyr::filter(list_name ==
ls_name & name %in% choices) %>% dplyr::pull(name) %>%
paste(collapse = " ")
newvalue <- tool.choices %>% dplyr::filter(list_name ==
ls_name & name %in% choices) %>% dplyr::pull(name) %>%
paste(collapse = " ")
newvalue
anychoice_pattern <- paste0("(", choices, ")", collapse = "|")
anychoice_pattern
data %>% dplyr::filter(!!rlang::sym(variable) !=
newvalue)
data <- data %>% dplyr::filter(!!rlang::sym(variable) !=
newvalue)
recode.multiple.set.choices(data.row,
or.row$ref.name, choices = unique(choices), "Recoding other response",
other_var_name = or.row$name, tool.survey = tool.survey,
tool.choices = tool.choices)
recode.multiple.set.choices(data.row,
or.row$ref.name, choices = unique(choices), "Recoding other response",
other_var_name = or.row$name, tool.survey = tool.survey,
tool.choices = tool.choices) %>% View()
knitr::opts_chunk$set(echo = TRUE)
setwd(dirname(rstudioapi::getActiveDocumentContext()$path))
rm(list = ls())
directory_dictionary <- list(
research_cycle_name = 'xxxx',
round = 'xxxx',
dir.audits = "data/inputs/audits/reach/", # The directory to your audit files
dir.audits.check = "output/checking/audit/",# The directory to your audit summary files (you'll be checking these)
dir.requests = "output/checking/requests/", # the directory of your other_requests file
dir.responses = "output/checking/responses/", # the directory of your responses to open questions
enum_colname = "XXX", # the column that contains the enumerator ID,
enum_comments = 'XXX', # the column that contains the enumerator's comments,
filename.tool = "resources/MSNA_2023_Questionnaire_Final_CATI_cleaned.xlsx", # the name of your Kobo tool and its path
data_name = "XXXX.xlsx", # the name of your dataframe
data_path = "data/inputs/kobo_export/", # the path to your dataframe
label_colname = 'label::English', # the name of your label column. Has to be identical in Kobo survey and choices sheets
dctime_short = "XXXX" # the data of your survey (just for naming)
)
api_key <- source('resources/microsoft.api.key_regional.R')$value
#-------------------------------Initialize packages, load tools -----------------------------
source("src/init.R")
source("src/load_Data.R")
# load a single raw Kobo data export:
# and loads the data into kobo.raw.main, kobo.raw.loop1...
# also included are the standard steps of renaming uuid, and adding the loop_index
raw_data_filename <- list.files(directory_dictionary$data_path, full.names = T)
if(length(raw_data_filename) > 1) { stop("Found multiple files containing raw Kobo data! Please clean up the kobo_export folder.")
}else if(length(raw_data_filename) == 0){
warning("Raw Kobo data not found!")
kobo.raw.main <- data.frame()
kobo.raw.loop1 <- data.frame()
dataset_creation_time <- NA
dctime_short <- ""
}else if(length(raw_data_filename) == 1){
ls <- excel_sheets(path = raw_data_filename)
sheet_names <- if(length(ls)>1){
c('kobo.raw.main',paste0('kobo.raw.loop',1:(length(ls)-1)))
}else{
'kobo.raw.main'
}
for(i in 1:length(ls)){
if(i==1){
kobo.raw.main <- readxl::read_xlsx(raw_data_filename, col_types = "text", sheet = ls[i])
}else{
txt <- paste0(sheet_names[i],'=readxl::read_xlsx(raw_data_filename, col_types = "text", sheet = "',ls[i],'")
mutate(loop_index = paste0("loop',i-1,'_", loop_index))'
)
eval(parse(text = txt))
}
}
dataset_creation_time <- as.Date(file.info(raw_data_filename)$ctime)
dctime_short <- str_extract(gsub('-', '', str_sub(dataset_creation_time, 3)), "\\d+")
}
# load a single raw Kobo data export:
# and loads the data into kobo.raw.main, kobo.raw.loop1...
# also included are the standard steps of renaming uuid, and adding the loop_index
raw_data_filename <- list.files(directory_dictionary$data_path, full.names = T)
if(length(raw_data_filename) > 1) { stop("Found multiple files containing raw Kobo data! Please clean up the kobo_export folder.")
}else if(length(raw_data_filename) == 0){
warning("Raw Kobo data not found!")
kobo.raw.main <- data.frame()
kobo.raw.loop1 <- data.frame()
dataset_creation_time <- NA
dctime_short <- ""
}else if(length(raw_data_filename) == 1){
ls <- excel_sheets(path = raw_data_filename)
sheet_names <- if(length(ls)>1){
c('kobo.raw.main',paste0('kobo.raw.loop',1:(length(ls)-1)))
}else{
'kobo.raw.main'
}
for(i in 1:length(ls)){
if(i==1){
kobo.raw.main <- readxl::read_xlsx(raw_data_filename, col_types = "text", sheet = ls[i])
}else{
txt <- paste0(sheet_names[i],'=readxl::read_xlsx(raw_data_filename, col_types = "text", sheet = "',ls[i],'")%>%
mutate(loop_index = paste0("loop',i-1,'_", loop_index))'
)
eval(parse(text = txt))
}
}
dataset_creation_time <- as.Date(file.info(raw_data_filename)$ctime)
dctime_short <- str_extract(gsub('-', '', str_sub(dataset_creation_time, 3)), "\\d+")
}
rm(raw_data_filename)
tool.survey
tool.survey %>% tibble()
tool.survey$type %>% table()
tool.survey %>%
filter(grepl('(select_one)|(select_multiple)|(integer)|(decimal)'))
tool.survey %>%
filter(grepl('(select_one)|(select_multiple)|(integer)|(decimal)',type))
tool.survey %>%
filter(grepl('(select_one)|(select_multiple)|(integer)|(decimal)',type)) %>% pull(name)
names_tool <- tool.survey %>%
filter(grepl('(select_one)|(select_multiple)|(integer)|(decimal)',type)) %>% pull(name)
raw.main <- kobo.raw.main
sheet_names <- sheet_names[sheet_names!='kobo.raw.main']
sheet_names_new <- gsub('kobo.','',sheet_names)
if(length(sheet_names_new)>0){
for(i in 1:length(sheet_names_new)){
txt <- paste0(sheet_names_new[i],' <- ',sheet_names[i])
eval(parse(text=txt))
}
}
sheet_names_new
length(sheet_names_new)>0
{{sheet_names_new[1]}}
names_list <- names(raw.main)
if(length(sheet_names_new)>0){
for(frame in sheet_names_new){
names_loop <- names(!!sym(frame))
names_list <- c(names_list,names_loop)
}
}
frame
names(!!sym(frame))
paste0("names(",frame,")")
names_list <- names(raw.main)
if(length(sheet_names_new)>0){
for(frame in sheet_names_new){
txt <- paste0("names(",frame,")")
names_loop <- eval(parse(text=txt))
names_list <- c(names_list,names_loop)
}
}
names_list
names_missing <- setdiff(names_tool,names_list)
names_missing
paste0("some of the names in your tool are not present in your dataframe. Please double check if they were renamed",names_missing,collapse = ',')
paste0("some of the names in your tool are not present in your dataframe. Please double check if they were renamed",names_missing,collapse = ',\n')
paste0("some of the names in your tool are not present in your dataframe. Please double check if they were renamed: ",names_missing,collapse = ',\n')
cat(paste0("some of the names in your tool are not present in your dataframe. Please double check if they were renamed: ",names_missing,collapse = ',\n'))
paste0("some of the names in your tool are not present in your dataframe. Please double check if they were renamed: ",
paste0(names_missing,collapse = ',\n'))
cat(paste0("some of the names in your tool are not present in your dataframe. Please double check if they were renamed: ",
paste0(names_missing,collapse = ',\n')))
if(length(names_missing)>0){
stop(cat(paste0("some of the names in your tool are not present in your dataframe. Please double check if they were renamed: ",
paste0(names_missing,collapse = ',\n'))))
}
if(length(names_missing)>0){
stop((paste0("some of the names in your tool are not present in your dataframe. Please double check if they were renamed: ",
paste0(names_missing,collapse = ',\n'))))
}
names_missing
(paste0("some of the names in your tool are not present in your dataframe. Please double check if they were renamed: ",
paste0(names_missing,collapse = ',\n')))
stop((paste0("some of the names in your tool are not present in your dataframe. Please double check if they were renamed: ",
paste0(names_missing,collapse = ',\n'))))
help(stop)
# name that hosts the clean recode.others file, leave as '' if you don't have this file. Nothing will be recoded that way
name_clean_others_file <- 'UKR2308_MSNA_other_response_230802'
sheet_name_others <- 'Sheet2' # name of the sheet where you're holding your requests
or.edited  <- utilityR::load.requests(directory_dictionary$dir.requests,
name_clean_others_file,
sheet = sheet_name_others, validate = T)
or.edited
or.edited %>%
pull(name,ref.name)
names_tool <- or.edited %>%
pull(name,ref.name)
names_req <- or.edited %>%
pull(name,ref.name)
names_list <- names(raw.main)
if(length(sheet_names_new)>0){
for(frame in sheet_names_new){
txt <- paste0("names(",frame,")")
names_loop <- eval(parse(text=txt))
names_list <- c(names_list,names_loop)
}
}
names_missing <- setdiff(names_req,names_list)
names_missing
if(length(names_missing)>0){
stop((paste0("some of the names in your tool are not present in your dataframe. Please double check if they were renamed: ",
paste0(names_missing,collapse = ',\n'))),)
}
paste0("some of the names in your tool are not present in your dataframe. Please double check if they were renamed: ",
paste0(names_missing,collapse = ',\n'))
stop((paste0("some of the names in your tool are not present in your dataframe. Please double check if they were renamed: ",
paste0(names_missing,collapse = ',\n'))))
