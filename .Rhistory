is.loop = T,
data.main = raw.main) # a brand new deletion log
deletion.log.new <- bind_rows(deletion.log.new,deletion.log.loop)
}
}
deletion.log.loop
deletion.log.new
sheet_names_new
paste0(loop,'<-',loop,'[!(',loop,'$uuid %in% deletion.log.new$uuid),]')
source('src/sections/section_1_remove_duplicates_no_consents.R')
loop
txt
# --------------------------------Section  2  - Audit checks + soft duplicates -----------------------------------
min_duration_interview <- 5 # minimum duration of an interview (screen time in minutes)
max_duration_interview <- 60 # maximum duration of an interview (screen time in minutes)
pre_process_audit_files <- F # whether cases of respondent taking too long to answer 1 question should cleaned.
max_length_answer_1_question <- 20 # if pre_process_audit_files =T, enter the maximum time that
# the respondent can spend answering 1 question (in minutes)
min_num_diff_questions <- 12 # Used during the check for soft duplicates.
# the respondent can spend answering 1 question (in minutes)
min_num_diff_questions <- 8 # Used during the check for soft duplicates.
paste0(loop,'<-',loop,'[!(',loop,'$uuid %in% deletion.log.new$uuid),]')
sheet_names_new
sheet_names_new[[i]]
paste0('int_cols_loop',i,' <- tool.survey %>%
filter(type == "integer" & datasheet != "main" & name %in% names(',sheet_names_new[[i]],')) %>%
pull(name)')
paste0('cl_log_999_loop',i,' <- utilityR::recode.set.NA.if(raw.loop1,int_cols_loop1, code = code_for_check,issue = "Wrong entry")')
paste0(' bind_rows(cl_log_999,cl_log_999_loop',i,')')
paste0(
'datasheets <-list("main" =kobo.raw.main,',
paste0('"',ls_loops,'" = ',data.list, collapse = ','),')'
)
ls
apply(raw.main,2, function(x){
grepl('[\p{Cyrillic}]',x)
apply(raw.main,2, function(x){
grepl('[\\u0400-\\u04FF]',x)
})
names(raw.main)[-'uuid']
names(raw.main)
names(raw.main)[names(raw.main)!='uuid']
raw.main %>%
pivot_longer(cols= names(raw.main)[names(raw.main)!='uuid'], names_to = column, values_to = value)
raw.main %>%
pivot_longer(cols= names(raw.main)[names(raw.main)!='uuid'], names_to = 'column', values_to = 'value')
raw.main %>%
pivot_longer(cols= names(raw.main)[names(raw.main)!='uuid'], names_to = 'column', values_to = 'value') %>%
filter(grepl('[\\u0400-\\u04FF]',value))
raw.main %>%
pivot_longer(cols= names(raw.main)[names(raw.main)!='uuid'], names_to = 'column', values_to = 'value') %>%
filter(grepl('[а-я]',value))
raw.main %>%
pivot_longer(cols= names(raw.main)[names(raw.main)!='uuid'], names_to = 'column', values_to = 'value') %>%
filter(grepl('[а-яА-я]',value))
source('src/sections/section_4_apply_changes_to_requests.R')
name_clean_others_file <- 'DS_r2_other_requests_final_2023_12_04'
cleaning.log <- data.frame()
or.edited  <- utilityR::load.requests(directory_dictionary$dir.requests,
name_clean_others_file,
sheet = "Sheet2", validate = T)  # specify Sheet2 because the first one is a readme
if(any(or.edited$check == 1)){
issue <- paste0('uuid: ', or.edited[or.edited$check == 1,]$uuid,', variable: ',or.edited[or.edited$check == 1,]$name)
stop(paste0('Some of your entries have errors, please double-check: ', paste0(issue,collapse = '\n')))
}
or.edited <- or.edited[or.edited$check>1,]
# this is for the test purposes. You won't have to run it when you've worked through everything
or.edited <- or.edited %>%
filter(!(is.na(true.v)&is.na(existing.v) & is.na(invalid.v)))
# separate the other translations to fit each individual dataframe that you have - no unnecessary variables in each
raw.main_requests <- or.edited %>%
filter(name %in% names(raw.main))
if(exists('raw.loop1')){
raw.loop1_requests <- or.edited %>%
filter(name %in% names(raw.loop1))
if(nrow(raw.loop1_requests)==0){
rm(raw.loop1_requests)
}
}
if(exists('raw.loop2')){
raw.loop2_requests <- or.edited %>%
filter(name %in% names(raw.loop2))
if(nrow(raw.loop2_requests)==0){
rm(raw.loop2_requests)
}
}
if(exists('raw.loop3')){
raw.loop3_requests <- or.edited %>%
filter(name %in% names(raw.loop3))
if(nrow(raw.loop3_requests)==0){
rm(raw.loop3_requests)
}
}
if(!(nrow(raw.main_requests)+nrow(raw.loop1_requests)+nrow(raw.loop2_requests)+nrow(raw.loop3_requests)==nrow(or.edited))){
warning('The number of rows in each of the separated dataframes does not match the number of total rows. This may mean
that some of the variables in your edited file are not present in the dataframes')
all_names <- unique(c(
names(raw.main),names(raw.loop1),names(raw.loop2),names(raw.loop3)
))
print('Variables that may be causing this issue:')
print(setdiff(or.edited$name,all_names))
}
# If you face any weird double spaces
tool.choices$`label::English`=str_squish(tool.choices$`label::English`)
# Create a cleaning log file for each loop if there's a need for it.
cleaning.log.other.main <- utilityR::recode.others(data = raw.main,
or.edited = raw.main_requests,
orig_response_col = 'responses',
is.loop = F,
tool.choices = tool.choices,
tool.survey = tool.survey)
raw.main %>%
pivot_longer(cols= names(raw.main)[names(raw.main)!='uuid'], names_to = 'column', values_to = 'value') %>%
filter(grepl('[а-яА-я]',value))
if(exists('raw.loop1_requests')){
cleaning.log.other.loop1 <- utilityR::recode.others(data = raw.loop1,
or.edited = raw.loop1_requests,
orig_response_col = 'responses',
is.loop = T,
tool.choices = tool.choices,
tool.survey = tool.survey)
}else{cleaning.log.other.loop1 <- data.frame()}
raw.loop1_requests
raw.loop1
raw.loop1$loop_index
raw.loop1$loop_index
raw.loop3$loop_index
raw.loop2$loop_index
source("src/load_Data.R")
raw.loop2$loop_index
raw.main <- kobo.raw.main
sheet_names <- sheet_names[sheet_names!='kobo.raw.main']
sheet_names_new <- gsub('kobo.','',sheet_names)
if(length(sheet_names_new)>0){
for(i in 1:length(sheet_names_new)){
txt <- paste0(sheet_names_new[i],' <- ',sheet_names[i])
eval(parse(text=txt))
}
}
raw.loop2$loop_index
raw.loop1$loop_index
raw.loop3$loop_index
if(nrow(cleaning.log.other.loop1>0)){
raw.loop1 <- utilityR::apply.changes(raw.loop1,clog = cleaning.log.other.loop1,is.loop = T)
}
cleaning.log.other.main
# Create the cleaning log for recoding others
cleaning.log.other <- rbind(cleaning.log.other.main,cleaning.log.other.loop1,
cleaning.log.other.loop2,
cleaning.log.other.loop3
)
# bind it with the main cleaning log
cleaning.log <- bind_rows(cleaning.log, cleaning.log.other)
## Apply changes from the cleaning log onto our raw data
raw.main <- utilityR::apply.changes(raw.main, clog = cleaning.log.other.main,is.loop = F)
raw.main %>%
pivot_longer(cols= names(raw.main)[names(raw.main)!='uuid'], names_to = 'column', values_to = 'value') %>%
filter(grepl('[а-яА-я]',value))
raw.main %>%
pivot_longer(cols= names(raw.main)[names(raw.main)!='uuid'], names_to = 'column', values_to = 'value') %>%
filter(grepl('[а-яА-я]',value)) %>% pull(column) %>% unique
sheet_names_new
names(raw.main)[names(raw.main) `%not=%` vars_to_omit]
vars_to_omit <- c('uuid','loop_index')
raw.main %>%
pivot_longer(cols= names(raw.main)[names(raw.main) %not=% vars_to_omit], names_to = 'column', values_to = 'value') %>%
filter(grepl('[а-яА-я]',value))
raw.main %>%
pivot_longer(cols= names(raw.main)[!names(raw.main) %in% vars_to_omit], names_to = 'column', values_to = 'value') %>%
filter(grepl('[а-яА-я]',value))
paste0('cyrillic.',i,' <- ',i,' %>%
pivot_longer(cols= names(raw.main)[!names(raw.main) %in% vars_to_omit], names_to = 'variable', values_to = 'value') %>%
paste0('cyrillic.',i,' <- ',i,' %>%
pivot_longer(cols= names(raw.main)[!names(raw.main) %in% vars_to_omit], names_to = "variable", values_to = "value") %>%
filter(grepl("[а-яА-я]",value))')
sheet_names_new
sheet_names_new
i="raw.loop1"
paste0('cyrillic.',i,' <- ',i,' %>%
pivot_longer(cols= names(raw.main)[!names(raw.main) %in% vars_to_omit], names_to = "variable", values_to = "value") %>%
filter(grepl("[а-яА-я]",value))')
paste0('cyrillic.',i,' <- ',i,' %>%
pivot_longer(cols= names(',i,')[!names(',i,') %in% vars_to_omit], names_to = "variable", values_to = "value") %>%
filter(grepl("[а-яА-я]",value))')
help(get.select.db
)
aste0('if(nrow(cyrillic.',i,')>0')
paste0('if(nrow(cyrillic.',i,')>0')
paste0('if(nrow(cyrillic.',i,')>0){
warning("Your data sill has cyrillic entries, please check file cyrillic.',i,' for details")
}
')
cyrillic.main <- raw.main %>%
pivot_longer(cols= names(raw.main)[!names(raw.main) %in% vars_to_omit], names_to = 'variable', values_to = 'value') %>%
filter(grepl('[а-яА-я]',value))
if(nrow(cyrillic.main)>0){
warning('Your data sill has cyrillic entries, please check file cyrillic.main for details')
}
if(length(sheet_names_new)>0){
for(i in sheet_names_new){
txt <- paste0('cyrillic.',i,' <- ',i,' %>%
pivot_longer(cols= names(',i,')[!names(',i,') %in% vars_to_omit], names_to = "variable", values_to = "value") %>%
filter(grepl("[а-яА-я]",value))')
eval(parse(text=txt))
txt <- paste0('if(nrow(cyrillic.',i,')>0){
warning("Your data sill has cyrillic entries, please check file cyrillic.',i,' for details")
}')
eval(parse(text=txt))
}
}
source('src/sections/section_4_post_check_for_leftover_cyrillic.R')
View(cyrillic.raw.loop3)
setwd(dirname(rstudioapi::getActiveDocumentContext()$path))
rm(list = ls())
directory_dictionary <- list(
dir.audits = "data/inputs/audits/reach/", # The directory to your audit files
dir.audits.check = "output/checking/audit/",# The directory to your audit summary files (you'll be checking these)
dir.requests = "output/checking/requests/", # the directory of your other_requests file
dir.responses = "output/checking/responses/", # the directory of your responses to open questions
enum_colname = "enumerator_id", # the column that contains the enumerator ID,
enum_comments = 'enum_comms', # the column that contains the enumerator's comments,
filename.tool = "resources/Reach_UKR2306_CCCM_DS_tool_r2_v3 1.xlsx", # the name of your Kobo tool and its path
data_name = "Reach_UKR2306_CCCM_DS_tool_r2_-_all_versions_-_False_-_2023-11-25-09-58-22 (1).xlsx", # the name of your dataframe
data_path = "data/inputs/kobo_export/", # the path to your dataframe
label_colname = 'label::English', # the name of your label column. Has to be identical in Kobo survey and choices sheets
dctime_short = "2023_01_01" # the data of your survey (just for naming)
)
api_key <- source('resources/microsoft.api.key_regional.R')$value
#-------------------------------Initialize packages, load tools -----------------------------
source("src/init.R")
sheet_names[i]
raw_data_filename <- list.files(directory_dictionary$data_path, full.names = T)
if(length(raw_data_filename) > 1) { stop("Found multiple files containing raw Kobo data! Please clean up the kobo_export folder.")
}else if(length(raw_data_filename) == 0){
warning("Raw Kobo data not found!")
kobo.raw.main <- data.frame()
kobo.raw.loop1 <- data.frame()
dataset_creation_time <- NA
dctime_short <- ""
}else if(length(raw_data_filename) == 1){
ls <- excel_sheets(path = raw_data_filename)
sheet_names <- c('kobo.raw.main',paste0('kobo.raw.loop',1:(length(ls)-1)))
for(i in 1:length(ls)){
if(i==1){
kobo.raw.main <- readxl::read_xlsx(raw_data_filename, col_types = "text", sheet = ls[i]) %>%
rename(uuid = "_uuid",
submission_time = "_submission_time",
index = "_index") %>%
rename_all(~sub("_geolocation","geolocation", .x))
}else{
txt <- paste0(sheet_names[i],'=readxl::read_xlsx(raw_data_filename, col_types = "text", sheet = "',ls[i],'")%>%
rename(uuid = "_submission__uuid",
loop_index = "_index",
parent_index = "_parent_index",
submission_id = "_submission__id",
submission_submission_time ="_submission__submission_time") %>%
mutate(loop_index = paste0("loop',i-1,'_", loop_index))'
)
eval(parse(text = txt))
}
}
dataset_creation_time <- as.Date(file.info(raw_data_filename)$ctime)
dctime_short <- str_extract(gsub('-', '', str_sub(dataset_creation_time, 3)), "\\d+")
}
sheet_names
!!sym( "kobo.raw.loop1")
!!sym("kobo.raw.loop1")
sym( "kobo.raw.loop1")
sym("kobo.raw.loop1")
sym("kobo.raw.loop1$uuid")
!!sym("kobo.raw.loop1$uuid")
kobo.raw.loop1$loop_index
kobo.raw.loop2$loop_index %>%  head()
kobo.raw.loop3$loop_index %>%  head()
#############################################################################################################
# 5) Outliers
#############################################################################################################
# save.image(file = "Environment.RData")
# load("Environment.RData")
n.sd <- 3
# specify methods for  detecting outliers
method <- "o1"
# ignore 0 values or not
ignore_0 <- T
# specify columns for check or leave them empty
cols.integer_raw.main <- c()
cols.integer_raw.loop1 <- c()
cols.integer_raw.loop2 <- c()
cols.integer_raw.loop3 <- c()
cleaning.log.outliers <- data.frame()
cols.integer_main <- filter(tool.survey, type == "integer")
if (length(cols.integer_raw.main) == 0) cols.integer_raw.main <- cols.integer_main[cols.integer_main$name %in% colnames(raw.main),] %>% pull(name)
raw.main <- kobo.raw.main
sheet_names <- sheet_names[sheet_names!='kobo.raw.main']
sheet_names_new <- gsub('kobo.','',sheet_names)
if(length(sheet_names_new)>0){
for(i in 1:length(sheet_names_new)){
txt <- paste0(sheet_names_new[i],' <- ',sheet_names[i])
eval(parse(text=txt))
}
}
cols.integer_main <- filter(tool.survey, type == "integer")
if (length(cols.integer_raw.main) == 0) cols.integer_raw.main <- cols.integer_main[cols.integer_main$name %in% colnames(raw.main),] %>% pull(name)
cols.integer_raw.main
if (length(cols.integer_raw.loop1) == 0) cols.integer_raw.loop1 <- cols.integer_main[cols.integer_main$name %in% colnames(raw.loop1),] %>% pull(name)
if (length(cols.integer_raw.loop2) == 0) cols.integer_raw.loop2 <- cols.integer_main[cols.integer_main$name %in% colnames(raw.loop2),] %>% pull(name)
if (length(cols.integer_raw.loop3) == 0) cols.integer_raw.loop3 <- cols.integer_main[cols.integer_main$name %in% colnames(raw.loop3),] %>% pull(name)
cols.integer_raw.loop2
cols.integer_raw.loop1
outliers.list <- c()
raw.data_frames.list <- c()
columns.list <- c()
if (length(cols.integer_raw.main) != 0) {
raw.main.outliers <- detect.outliers(
df = raw.main,
id = 'uuid',
colnames = cols.integer_raw.main,
is.loop = F,
n.sd = n.sd,
method = method,
ignore_0=ignore_0)
outliers.list <- c(outliers.list, list(raw.main.outliers))
raw.data_frames.list <- c(raw.data_frames.list, list(raw.main))
columns.list <- c(columns.list, list(cols.integer_raw.main))
} else raw.main.outliers <- data.frame()
detect.outliers
if (length(cols.integer_raw.main) != 0) {
raw.main.outliers <- utilityR::detect.outliers(
df = raw.main,
id = 'uuid',
colnames = cols.integer_raw.main,
is.loop = F,
n.sd = n.sd,
method = method,
ignore_0=ignore_0)
outliers.list <- c(outliers.list, list(raw.main.outliers))
raw.data_frames.list <- c(raw.data_frames.list, list(raw.main))
columns.list <- c(columns.list, list(cols.integer_raw.main))
} else raw.main.outliers <- data.frame()
detach("package:utilityR", unload = TRUE)
remove.packages("utilityR")
devtools::install_github('Nestor-Ch/utilityR')
utilityR::detect.outliers
if (length(cols.integer_raw.main) != 0) {
raw.main.outliers <- utilityR::detect.outliers(
df = raw.main,
id = 'uuid',
colnames = cols.integer_raw.main,
is.loop = F,
n.sd = n.sd,
method = method,
ignore_0=ignore_0)
outliers.list <- c(outliers.list, list(raw.main.outliers))
raw.data_frames.list <- c(raw.data_frames.list, list(raw.main))
columns.list <- c(columns.list, list(cols.integer_raw.main))
} else raw.main.outliers <- data.frame()
raw.main.outliers
if (length(cols.integer_raw.loop1) != 0) {
raw.loop1.outliers <- detect.outliers(
df = raw.loop1,
id = 'loop_index',
colnames = cols.integer_raw.loop1,
is.loop = T,
n.sd = n.sd,
method = method,
ignore_0=ignore_0)
outliers.list <- c(outliers.list, list(raw.loop1.outliers))
raw.data_frames.list <- c(raw.data_frames.list, list(raw.loop1))
columns.list <- c(columns.list, list(cols.integer_raw.loop1))
} else raw.loop1.outliers <- data.frame()
if (length(cols.integer_raw.loop1) != 0) {
raw.loop1.outliers <- utilityR::detect.outliers(
df = raw.loop1,
id = 'loop_index',
colnames = cols.integer_raw.loop1,
is.loop = T,
n.sd = n.sd,
method = method,
ignore_0=ignore_0)
outliers.list <- c(outliers.list, list(raw.loop1.outliers))
raw.data_frames.list <- c(raw.data_frames.list, list(raw.loop1))
columns.list <- c(columns.list, list(cols.integer_raw.loop1))
} else raw.loop1.outliers <- data.frame()
if (length(cols.integer_raw.loop2) != 0) {
raw.loop2.outliers <- utilityR::detect.outliers(
df = raw.loop2,
id = 'loop_index',
colnames = cols.integer_raw.loop2,
is.loop = T,
n.sd = n.sd,
method = method,
ignore_0=ignore_0)
print(raw.loop2.outliers)
outliers.list <- c(outliers.list, list(raw.loop2.outliers))
raw.data_frames.list <- c(raw.data_frames.list, list(raw.loop2))
columns.list <- c(columns.list, list(cols.integer_raw.loop2))
} else raw.loop2.outliers <- data.frame()
raw.loop2.outliers
if (length(cols.integer_raw.loop3) != 0) {
raw.loop3.outliers <- utilityR::detect.outliers(
df = raw.loop3,
id = 'loop_index',
colnames = cols.integer_raw.loop3,
is.loop = T,
n.sd = n.sd,
method = method,
ignore_0=ignore_0)
outliers.list <- c(outliers.list, list(raw.loop3.outliers))
raw.data_frames.list <- c(raw.data_frames.list, list(raw.loop3))
columns.list <- c(columns.list, list(cols.integer_raw.loop3))
} else raw.loop3.outliers <- data.frame()
raw.loop3.outliers
generate.boxplot(outliers.list=outliers.list,
raw.data_frames.list=raw.data_frames.list,
columns.list=columns.list,
n.sd=n.sd, boxplot.path = "output/checking/outliers/outlier_analysis_")
utilityR::generate.boxplot(outliers.list=outliers.list,
raw.data_frames.list=raw.data_frames.list,
columns.list=columns.list,
n.sd=n.sd, boxplot.path = "output/checking/outliers/outlier_analysis_")
utilityR::generate.boxplot(outliers.list=outliers.list,
raw.data_frames.list=raw.data_frames.list,
columns.list=columns.list,
n.sd=n.sd, boxplot.path = "output/checking/outliers/outlier_analysis_")
raw.loop3.outliers
paste0("output/checking/outliers/main_outlier_analysis_", n.sd, "sd.xlsx")
paste0("output/checking/outliers/loop1_outlier_analysis_", n.sd, "sd.xlsx")
rbind(raw.main.outliers,raw.loop1.outliers,raw.loop2.outliers,raw.loop3.outliers)
clean.log.outliers <- rbind(raw.main.outliers,raw.loop1.outliers,raw.loop2.outliers,raw.loop3.outliers)
source('src/sections/section_4_post_check_for_leftover_cyrillic.R')
vars_to_omit <- c('uuid','loop_index') # add more names as needed
source('src/sections/section_4_post_check_for_leftover_cyrillic.R')
cyrillic.main
if(length(sheet_names_new)>0){
for(i in sheet_names_new){
txt <- paste0('cyrillic.',i,' <- ',i,' %>%
pivot_longer(cols= names(',i,')[!names(',i,') %in% vars_to_omit], names_to = "variable", values_to = "value") %>%
filter(grepl("[\\u0400-\\u04FF\\u0500-\\u052F\\u2DE0-\\u2DFF\\uA640-\\uA69F\\u1C80-\\u1C8F]",value, perl=T))')
eval(parse(text=txt))
txt <- paste0('if(nrow(cyrillic.',i,')>0){
warning("Your data sill has cyrillic entries, please check file cyrillic.',i,' for details")
}')
eval(parse(text=txt))
}
}
cyrillic.raw.loop1
if(length(sheet_names_new)>0){
for(i in sheet_names_new){
txt <- paste0('cyrillic.',i,' <- ',i,' %>%
pivot_longer(cols= names(',i,')[!names(',i,') %in% vars_to_omit], names_to = "variable", values_to = "value") %>%
filter(grepl("[а-яА-я]",value))')
eval(parse(text=txt))
txt <- paste0('if(nrow(cyrillic.',i,')>0){
warning("Your data sill has cyrillic entries, please check file cyrillic.',i,' for details")
}')
eval(parse(text=txt))
}
}
cyrillic.raw.loop1
utilityR::recode.set.NA.if
utilityR::recode.set.NA.if(raw.main,c('99','999'), code = 'code_for_check',issue = 'Wrong entry')
utilityR::recode.set.NA.if(raw.main,int_cols_main, code = code_for_check,issue = 'Wrong entry')
# get the integers from main
int_cols_main  <- tool.survey %>%
filter(type == "integer" & datasheet == "main") %>%
pull(name)
utilityR::recode.set.NA.if(raw.main,int_cols_main, code = code_for_check,issue = 'Wrong entry')
utilityR::recode.set.NA.if(raw.main,int_cols_main, code = c('99'),issue = 'Wrong entry')
utilityR::recode.set.NA.if(raw.main,int_cols_main, code = c('99','999'),issue = 'Wrong entry')
utilityR::recode.set.NA.if(raw.main,int_cols_main, code = c('99','999','9'),issue = 'Wrong entry')
raw.main
# variables that will be omitted from the analysis
vars_to_omit <- c('settlement') # add more names as needed
raw.main %>%
select(-vars_to_omit)
raw.main %>%
select(-any_of(vars_to_omit))
raw.loop1 %>%
select(-any_of(vars_to_omit))
raw.loop1 %>%
select(-any_of('vars_to_omit'))
paste0('cyrillic.',i,' <- ',i,' %>%
select(-any_of(vars_to_omit)) %>%
pivot_longer(cols= names(',i,')[!names(',i,') %in% id_columns], names_to = "variable", values_to = "value") %>%
filter(grepl("[\\u0400-\\u04FF\\u0500-\\u052F\\u2DE0-\\u2DFF\\uA640-\\uA69F\\u1C80-\\u1C8F]",value, perl=T))')
name_clean_others_file != ''
directory_dictionary$dir.audits.check
# --------------------------------Section  2  - Audit checks + soft duplicates -----------------------------------
min_duration_interview <- 5 # minimum duration of an interview (screen time in minutes)
max_duration_interview <- 60 # maximum duration of an interview (screen time in minutes)
pre_process_audit_files <- F # whether cases of respondent taking too long to answer 1 question should cleaned.
# if pre_process_audit_files =T, enter the maximum time that  the respondent can spend answering 1 question (in minutes)
max_length_answer_1_question <- 20
min_num_diff_questions <- 8 # Used during the check for soft duplicates.
check.last.digit(raw.main)
check.last.digit <- function(df){
res <- data.frame()
for (col in colnames(df)[2:length(colnames(df))]){
df.temp <- data.frame(id=df$uuid, value=df[[col]]) %>%
filter(!is.na(value) & value!="0") %>%
mutate(len=str_length(value),
last1=ifelse(len==1, value, str_sub(value, len, len)),
last2=ifelse(len<=2, value, str_sub(value, len-1, len)),
variable=col) %>%
filter(!(last1 %in% c("0"))) %>%
mutate(check.id="Typing", old.value=value, new.value=NA) %>%
select(id, check.id, variable, old.value, new.value)
res <- rbind(res, df.temp)
}
return(res)
}
check.last.digit(raw.main)
