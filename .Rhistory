cat("Total number of select_one other responses:", nrow(or.select_one),
"\n")
}
s1_data <- data %>% dplyr::filter(uniqui %in% or.select_one$uniqui)
if (nrow(s1_data) == 0) {
cl_select_one <- dplyr::tibble()
}
else {
cl_select_one <- recode.others_select_one(or.select_one,
print_debug = print_debug, tool.survey_others = tool.survey,
tool.choices_others = tool.choices, orig_response_col = orig_response_col,
label_colname = label_colname)
}
or.select_multiple <- or.edited %>% dplyr::filter(ref.type ==
"select_multiple")
if (print_debug) {
cat("Total number of select_multiple other responses:",
nrow(or.select_multiple), "\n")
}
sm_data <- data %>% dplyr::filter(uniqui %in% or.select_multiple$uniqui)
if (nrow(sm_data) == 0) {
cl_select_multiple <- dplyr::tibble()
}
else {
cl_select_multiple <- recode.others_select_multiple2(data = sm_data,
or.select_multiple = or.select_multiple, orig_response_col = orig_response_col,
print_debug = print_debug, tool.survey_others = tool.survey,
tool.choices_others = tool.choices, is.loop = is.loop,
label_colname = label_colname)
}
cl_all_others <- bind_rows(cl_select_one, cl_select_multiple) %>%
dplyr::filter(old.value %not=na% new.value)
return(cl_all_others)
}
recode.others_select_multiple2 <- function (data, or.select_multiple, orig_response_col = "response.uk",
print_debug = T, is.loop, tool.survey_others = tool.survey,
tool.choices_others = tool.choices, label_colname = "label::English",
CL_COLS = c("uuid", "uniqui", "loop_index", "variable",
"old.value", "new.value", "issue"))
{
if (!"uuid" %in% names(data) & is.loop) {
stop(print("Your loop data doesnt have the uuid variable, please check the data and rename uuid appropriately"))
}
if (any(!or.select_multiple$uniqui %in% data$uniqui)) {
cat(paste0("The following unique IDs from your requests file were not found in the data provided: ",
paste0(dplyr::setdiff(or.select_multiple$uniqui,
data$uniqui), collapse = ", "), ". Please double check "))
or.select_multiple <- or.select_multiple[or.select_multiple$uniqui %in%
data$uniqui, ]
}
or.select_multiple.remove <- dplyr::filter(or.select_multiple,
!is.na(invalid.v))
cl_sm_remove <- dplyr::tibble()
if (nrow(or.select_multiple.remove) > 0) {
if (print_debug) {
cat(paste("Number of invalid select_multiple responses:",
nrow(or.select_multiple.remove)), "\n")
}
variables <- or.select_multiple.remove %>% dplyr::select(ref.name,
name) %>% dplyr::distinct(ref.name, .keep_all = T)
for (variable in variables %>% dplyr::pull(ref.name)) {
thisvar_data <- data %>% dplyr::filter(uniqui %in%
(or.select_multiple.remove %>% dplyr::filter(ref.name ==
variable) %>% dplyr::pull(uniqui)))
other_variable <- variables$name[which(variables$ref.name ==
variable)]
cl_only_other <- thisvar_data %>% dplyr::filter(!!rlang::sym(variable) ==
"other") %>% recode.multiple.set.NA(variable,
"Invalid other response", other_var_name = other_variable,
CL_COLS = CL_COLS)
cl_notjust_other <- thisvar_data %>% dplyr::filter(!!rlang::sym(variable) !=
"other") %>% recode.multiple.remove.choices(variable,
"other", "Invalid other response", other_var_name = other_variable,
CL_COLS = CL_COLS)
cl_sm_remove <- bind_rows(cl_sm_remove, cl_only_other,
cl_notjust_other)
}
}
or.select_multiple.recode <- or.select_multiple %>% dplyr::filter(!is.na(existing.v)) %>%
dplyr::mutate(list_name = sapply(ref.name, function(x) {
get.choice.list.from.name(x, tool.survey = tool.survey_others)
}), existing.v = stringr::str_split(stringr::str_squish(existing.v),
" *; *", simplify = T))
cl_sm_recode <- dplyr::tibble()
if (nrow(or.select_multiple.recode) > 0) {
if (print_debug) {
cat(paste("Number of select_multiple responses to be recoded:",
nrow(or.select_multiple.recode)), "\n")
}
choices_lookup <- tool.choices_others %>% dplyr::filter(list_name %in%
or.select_multiple.recode$list_name) %>% dplyr::rename(label = !!rlang::sym(label_colname),
choice_name = name)
for (r in 1:nrow(or.select_multiple.recode)) {
or.row <- or.select_multiple.recode[r, ]
data.row <- data %>% dplyr::filter(uniqui == or.row$uniqui)
chosen_labels <- or.row$existing.v[or.row$existing.v !=
"" & !is.na(or.row$existing.v)]
if (any(!chosen_labels %in% choices_lookup$label)) {
stop("Choice '", paste(chosen_labels[!chosen_labels %in%
choices_lookup$label], collapse = "' "), "' not found in list ",
or.row$list_name)
}
choices <- choices_lookup %>% dplyr::filter(list_name ==
or.row$list_name & label %in% chosen_labels) %>%
dplyr::pull(choice_name)
if (!is.na(or.row$true.v)) {
cl_sm_recode <- bind_rows(cl_sm_recode, or.row %>%
dplyr::mutate(variable = name, old.value = !!rlang::sym(orig_response_col),
new.value = true.v, issue = "Translating other response") %>%
dplyr::select(any_of(CL_COLS)))
cl_sm_recode_add_choice <- recode.multiple.add.choices(data.row,
or.row$ref.name, choices, "Recoding other response")
cl_sm_recode <- cl_sm_recode %>% dplyr::mutate_all(as.character)
cl_sm_recode_add_choice <- cl_sm_recode_add_choice %>%
dplyr::mutate_all(as.character)
cl_sm_recode <- dplyr::bind_rows(cl_sm_recode,
cl_sm_recode_add_choice)
}
else {
old_choices <- data.row[[or.row$ref.name]] %>%
stringr::str_split(" ", simplify = T)
choices <- c(choices, old_choices[old_choices !=
"other"])
cl_sm_recode_add_ch <- recode.multiple.set.choices(data.row,
or.row$ref.name, choices, "Recoding other response",
other_var_name = or.row$name, tool.survey = tool.survey_others,
tool.choices = tool.choices_others)
cl_sm_recode_add_ch <- cl_sm_recode_add_ch %>%
dplyr::mutate_all(as.character)
cl_sm_recode <- dplyr::bind_rows(cl_sm_recode,
cl_sm_recode_add_ch)
}
}
}
or.select_multiple.true <- or.select_multiple %>% dplyr::filter(!is.na(true.v) &
check == 2)
if (print_debug) {
cat(paste("Number of true select_multiple responses:",
nrow(or.select_multiple.true)), "\n")
}
cl_sm_true <- or.select_multiple.true %>% dplyr::mutate(variable = name,
old.value = !!rlang::sym(orig_response_col), new.value = true.v,
issue = "Translating other response") %>% dplyr::select(any_of(CL_COLS))
cl_sm_true <- cl_sm_true %>% dplyr::mutate_all(as.character)
cl_sm_remove <- cl_sm_remove %>% dplyr::mutate_all(as.character)
cl_sm_recode <- cl_sm_recode %>% dplyr::mutate_all(as.character)
result_fin <- dplyr::bind_rows(cl_sm_true, cl_sm_remove,
cl_sm_recode)
if (!is.loop & !"loop_index" %in% names(result_fin)) {
result_fin$loop_index <- NA_character_
}
return(result_fin)
}
# Create a cleaning log file for each loop if there's a need for it.
cleaning.log.other.main <- recode.others2(
data = raw.main,
or.edited = raw.main_requests,
orig_response_col = 'response.uk',
is.loop = F,
tool.choices = tool.choices,
tool.survey = tool.survey)
View(tool.choices)
'Bedding / blankets'=='Bedding /  blankets'
# If you face any weird double spaces
tool.choices$`label::English`=str_squish(tool.choices$`label::English`)
# Create a cleaning log file for each loop if there's a need for it.
cleaning.log.other.main <- recode.others2(
data = raw.main,
or.edited = raw.main_requests,
orig_response_col = 'response.uk',
is.loop = F,
tool.choices = tool.choices,
tool.survey = tool.survey)
View(cleaning.log.other.main)
View(or.edited)
detach("package:utilityR", unload = TRUE)
remove.packages("utilityR")
devtools::install_github('https://github.com/Nestor-Ch/utilityR', build_vignettes = T)
pacman::p_load(docstring, tidyverse, readxl, writexl, openxlsx, stringr,
sf, geosphere, qdapRegex, cluster, randomcoloR, svDialogs, scales, janitor, utilityR,zip)
# Create a cleaning log file for each loop if there's a need for it.
cleaning.log.other.main <- utilityR::recode.others(
data = raw.main,
or.edited = raw.main_requests,
orig_response_col = 'response.uk',
is.loop = F,
tool.choices = tool.choices,
tool.survey = tool.survey)
View(cleaning.log.other.main)
# these are the variables that have the relevancies related to their _other responses
select_multiple_list_relevancies <- c("F_1_main_source_drinking_water", "F_8_sanitation_facility", "K_14_services_women", "K_16_services_mhpss" )
# get the dictionary of the relevancies
relevancy_dictionary <- utilityR::find.relevances(tool.survey = tool.survey,
var_list = select_multiple_list_relevancies)
View(relevancy_dictionary)
raw.main_requests <- raw.main_requests[1:100,]
# Create a cleaning log file for each loop if there's a need for it.
cleaning.log.other.main <- utilityR::recode.others(
data = raw.main,
or.edited = raw.main_requests,
orig_response_col = 'response.uk',
is.loop = F,
tool.choices = tool.choices,
tool.survey = tool.survey)
raw.main_requests <- raw.main_requests[1:200,]
# Create a cleaning log file for each loop if there's a need for it.
cleaning.log.other.main <- utilityR::recode.others(
data = raw.main,
or.edited = raw.main_requests,
orig_response_col = 'response.uk',
is.loop = F,
tool.choices = tool.choices,
tool.survey = tool.survey)
View(tool.survey)
raw.main_requests <- raw.main_requests[500:1000,]
raw.main_requests
# separate the other translations to fit each individual dataframe that you have - no unnecessary variables in each
raw.main_requests <- or.edited %>%
filter(name %in% names(raw.main))
raw.main_requests[1:1000,]
raw.main_requests <- raw.main_requests[1:1000,]
# Create a cleaning log file for each loop if there's a need for it.
cleaning.log.other.main <- utilityR::recode.others(
data = raw.main,
or.edited = raw.main_requests,
orig_response_col = 'response.uk',
is.loop = F,
tool.choices = tool.choices,
tool.survey = tool.survey)
# these are the variables that have the relevancies related to their _other responses
select_multiple_list_relevancies <- c('I_1_income_sources')
# get the dictionary of the relevancies
relevancy_dictionary <- utilityR::find.relevances(tool.survey = tool.survey,
var_list = select_multiple_list_relevancies)
View(relevancy_dictionary)
relevancy_dictionary <- relevancy_dictionary[2:14,]
cleaning.log.other.main.relevances <- utilityR::recode.other.relevances(
data = raw.main,
cleaning.log.other = cleaning.log.other.main,
relevancy_dictionary = relevancy_dictionary,
is.loop = F)
cleaning.log.other.main.relevances
cleaning.log.other.main
View(cleaning.log.other.main)
View(or.edited)
which(raw.main_requests$ref.name=='I_1_income_sources')
# separate the other translations to fit each individual dataframe that you have - no unnecessary variables in each
raw.main_requests <- or.edited %>%
filter(name %in% names(raw.main))
which(raw.main_requests$ref.name=='I_1_income_sources')
# for the training
raw.main_requests <- raw.main_requests[1000:1500,]
# Create a cleaning log file for each loop if there's a need for it.
cleaning.log.other.main <- utilityR::recode.others(
data = raw.main,
or.edited = raw.main_requests,
orig_response_col = 'response.uk',
is.loop = F,
tool.choices = tool.choices,
tool.survey = tool.survey)
# separate the other translations to fit each individual dataframe that you have - no unnecessary variables in each
raw.main_requests <- or.edited %>%
filter(name %in% names(raw.main))
# for the training
raw.main_requests <- raw.main_requests[1400:1700,]
raw.main_requests$ref.type %>% table()
# separate the other translations to fit each individual dataframe that you have - no unnecessary variables in each
raw.main_requests <- or.edited %>%
filter(name %in% names(raw.main))
# for the training
raw.main_requests <- raw.main_requests[c(1:100,1400:1500),]
raw.main_requests$ref.type %>% table()
# Create a cleaning log file for each loop if there's a need for it.
cleaning.log.other.main <- utilityR::recode.others(
data = raw.main,
or.edited = raw.main_requests,
orig_response_col = 'response.uk',
is.loop = F,
tool.choices = tool.choices,
tool.survey = tool.survey)
relevancy_dictionary
cleaning.log.other.main.relevances <- utilityR::recode.other.relevances(
data = raw.main,
cleaning.log.other = cleaning.log.other.main,
relevancy_dictionary = relevancy_dictionary,
is.loop = F)
cleaning.log.other.main.relevances
cleaning.log.other.main
View(cleaning.log.other.main)
# separate the other translations to fit each individual dataframe that you have - no unnecessary variables in each
raw.main_requests <- or.edited %>%
filter(name %in% names(raw.main))
# for the training
raw.main_requests <- raw.main_requests[c(1:100,1300:1400),]
View(raw.main_requests)
raw.main_requests <- raw.main_requests[c(1:100,1300:1400),]
# If you face any weird double spaces
tool.choices$`label::English`=str_squish(tool.choices$`label::English`)
# Create a cleaning log file for each loop if there's a need for it.
cleaning.log.other.
# Create a cleaning log file for each loop if there's a need for it.
cleaning.log.other.main <- utilityR::recode.others(
data = raw.main,
or.edited = raw.main_requests,
orig_response_col = 'response.uk',
is.loop = F,
tool.choices = tool.choices,
tool.survey = tool.survey)
# separate the other translations to fit each individual dataframe that you have - no unnecessary variables in each
raw.main_requests <- or.edited %>%
filter(name %in% names(raw.main))
# for the training
raw.main_requests <- raw.main_requests[c(1:100,1300:1400),]
# Create a cleaning log file for each loop if there's a need for it.
cleaning.log.other.main <- utilityR::recode.others(
data = raw.main,
or.edited = raw.main_requests,
orig_response_col = 'response.uk',
is.loop = F,
tool.choices = tool.choices,
tool.survey = tool.survey)
cleaning.log.other.main.elsewhere <- utilityR::recode.others.elsewhere(
data= raw.main,
or.edited = raw.main_requests_elsewhere,
tool.survey = tool.survey,
is.loop = F)
cleaning.log.other.main.relevances <- utilityR::recode.other.relevances(
data = raw.main,
cleaning.log.other = cleaning.log.other.main,
relevancy_dictionary = relevancy_dictionary,
is.loop = F)
View(cleaning.log.other.main.relevances)
View(directory_dictionary)
View(deletion.log.new)
View(relevancy_dictionary)
cleaning.log.match <- utilityR::select.multiple.check(raw.main, tool.survey, id_col="uuid")
cleaning.log.other.main <- rbind(cleaning.log.other.main,cleaning.log.other.main.relevances)
## Apply changes from the cleaning log onto our raw data
raw.main <- utilityR::apply.changes(raw.main, clog = cleaning.log.other.main,is.loop = F)
source('src/sections/section_4_post_check_for_leftover_cyrillic.R')
# variables that will be omitted from the analysis
vars_to_omit <- c('settlement', directory_dictionary$enum_colname, directory_dictionary$enum_comments) # add more names as needed
source('src/sections/section_4_post_check_for_leftover_cyrillic.R')
View(cyrillic.main)
View(cleaning.log.match)
nrow(cleaning.log.match) > 0
code_for_check  <- c('99','999')
source('src/sections/section_5_create_999_checks.R')
source('src/sections/section_5_create_999_checks.R')
print(cl_log_999)
View(cl_log_999)
# specify the number of standard deviations you want to use
n.sd <- 3
# specify methods for  detecting outliers
method <- "o1"
# ignore 0 values or not
ignore_0 <- T
cols.integer_raw.main <- c()
cols.integer_raw.loop1 <- c()
cols.integer_raw.loop2 <- c()
cols.integer_raw.loop3 <- c()
source('src/sections/section_6_detect_and_visualise_outliers.R')
View(cleaning.log.outliers)
utilityR::save.other.requests
or.edited  <- utilityR::load.requests(directory_dictionary$dir.requests,
name_clean_others_file,
sheet = sheet_name_others, validate = T)
# separate the other translations to fit each individual dataframe that you have - no unnecessary variables in each
raw.main_requests <- or.edited %>%
filter(name %in% names(raw.main))
# for the training
raw.main_requests <- raw.main_requests[c(1:100,1300:1400),]
nrow(raw.main_requests[[!is.na(true_elsewhere)]])>0
nrow(raw.main_requests[[!is.na(raw.main_requests$true_elsewhere)]])>0
raw.main_requests$true_elsewhere
raw.main_requests[[!is.na(raw.main_requests$true_elsewhere)]]
raw.main_requests[!is.na(raw.main_requests$true_elsewhere),]
if(exists('raw.loop1')){
raw.loop1_requests <- or.edited %>%
filter(name %in% names(raw.loop1))
if(nrow(raw.loop1_requests)==0){
rm(raw.loop1_requests)
}
}
if(exists('raw.loop2')){
raw.loop2_requests <- or.edited %>%
filter(name %in% names(raw.loop2))
if(nrow(raw.loop2_requests)==0){
rm(raw.loop2_requests)
}
}
if(exists('raw.loop3')){
raw.loop3_requests <- or.edited %>%
filter(name %in% names(raw.loop3))
if(nrow(raw.loop3_requests)==0){
rm(raw.loop3_requests)
}
}
nrow(raw.loop1_requests[!is.na(raw.loop1_requests$true_elsewhere),])>0
raw.loop1_requests_elsewhere <- raw.loop1_requests[!is.na(raw.loop1_requests$true_elsewhere),]
raw.loop1_requests_elsewhere
cleaning.log.other.loop1.elsewhere <- utilityR::recode.others.elsewhere(
data= raw.loop1,
or.edited = raw.loop1_requests_elsewhere,
tool.survey = tool.survey,
is.loop = F)
cleaning.log.other.loop1.elsewhere <- utilityR::recode.others.elsewhere(
data= raw.loop1,
or.edited = raw.loop1_requests_elsewhere,
tool.survey = tool.survey,
is.loop = T)
raw.loop1_requests_elsewhere
View(raw.loop1_requests_elsewhere)
raw.loop1_requests_elsewhere
utilityR::recode.others.elsewhere(
data= raw.loop1,
or.edited = raw.loop1_requests_elsewhere,
tool.survey = tool.survey,
is.loop = T)
recode.others.elsewhere
cleaning.log.other.loop1.elsewhere <- utilityR::recode.others.elsewhere(
data= raw.loop1,
or.edited = raw.loop1_requests_elsewhere,
tool.survey = tool.survey,
is.loop = T)
View(raw.loop1_requests_elsewhere)
data.row <- raw.loop1[raw.loop1$loop_index=='loop1_2307',]
data.row[['A_17_hh_member_employment']]
remove.packages("utilityR")
devtools::install_github('https://github.com/Nestor-Ch/utilityR', build_vignettes = T)
pacman::p_load(docstring, tidyverse, readxl, writexl, openxlsx, stringr,
sf, geosphere, qdapRegex, cluster, randomcoloR, svDialogs, scales, janitor, utilityR,zip)
cleaning.log.other.loop1.elsewhere <- utilityR::recode.others.elsewhere(
data= raw.loop1,
or.edited = raw.loop1_requests_elsewhere,
tool.survey = tool.survey,
is.loop = T)
raw.loop1_requests_elsewhere
View(raw.loop1_requests_elsewhere)
or.edited  <- utilityR::load.requests(directory_dictionary$dir.requests,
name_clean_others_file,
sheet = sheet_name_others, validate = T)
which(!is.na(or.edited$true_column))
or.edited <- or.edited %>%
left_join(tool.survey %>% select(name,list_name) %>% rename(ref.name=name)) %>%
dplyr::rowwise() %>%
dplyr::mutate(existing.v.choice_label = sapply(stringr::str_split(choice, " "), function(choice_list) {
if (is.na(existing.v)) {
return("NA")
}
existing.v.list <- unlist(strsplit(existing.v, ";"))
for (ch in choice_list) {
if ((list_name %in% tool.choices$list_name)) {
label <- utilityR::get.choice.label(ch, list_name,
directory_dictionary$label_colname, tool.choices)
if ((is.element(label, existing.v.list))) {
existing.v.list <- existing.v.list[!existing.v.list %in% label]
}
} else {
stop(paste0("The choice list ", list_name, " does not exist in the tool.choices file"))
}
}
return(paste(existing.v.list, collapse = ";"))
})) %>%
dplyr::ungroup() %>%
mutate(existing.v = ifelse(existing.v.choice_label == '', NA, existing.v.choice_label),
invalid.v = ifelse(existing.v.choice_label == '', 'YES', invalid.v))
or.edited <- or.edited%>%
dplyr::select(-existing.v.choice_label)
# separate the other translations to fit each individual dataframe that you have - no unnecessary variables in each
raw.main_requests <- or.edited %>%
filter(name %in% names(raw.main))
if(exists('raw.loop1')){
raw.loop1_requests <- or.edited %>%
filter(name %in% names(raw.loop1))
if(nrow(raw.loop1_requests)==0){
rm(raw.loop1_requests)
}
}
if(exists('raw.loop2')){
raw.loop2_requests <- or.edited %>%
filter(name %in% names(raw.loop2))
if(nrow(raw.loop2_requests)==0){
rm(raw.loop2_requests)
}
}
if(exists('raw.loop3')){
raw.loop3_requests <- or.edited %>%
filter(name %in% names(raw.loop3))
if(nrow(raw.loop3_requests)==0){
rm(raw.loop3_requests)
}
}
# for the training
raw.main_requests <- raw.main_requests[c(1:100,1300:1400,5496),]
nrow(raw.loop1_requests[!is.na(raw.loop1_requests$true_elsewhere),])>0
nrow(raw.main_requests[!is.na(raw.main_requests$true_elsewhere),])>0
# separate the other translations to fit each individual dataframe that you have - no unnecessary variables in each
raw.main_requests <- or.edited %>%
filter(name %in% names(raw.main))
which(!is.na(raw.main_requests$true_column))
# for the training
raw.main_requests <- raw.main_requests[c(1:100,1300:1400,1678),]
nrow(raw.main_requests[!is.na(raw.main_requests$true_elsewhere),])>0
raw.main_requests_elsewhere <- raw.main_requests[!is.na(raw.main_requests$true_elsewhere),]
cleaning.log.other.main.elsewhere <- utilityR::recode.others.elsewhere(
data= raw.main,
or.edited = raw.main_requests_elsewhere,
tool.survey = tool.survey,
is.loop = F)
View(cleaning.log.other.main.elsewhere)
gc()
